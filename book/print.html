<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="mermaid.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="what_is_chalk.html"><strong aria-hidden="true">1.</strong> What is Chalk?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what_is_chalk/walkthrough.html"><strong aria-hidden="true">1.1.</strong> Walkthrough</a></li><li class="chapter-item expanded "><a href="what_is_chalk/crates.html"><strong aria-hidden="true">1.2.</strong> Crates</a></li><li class="chapter-item expanded "><a href="what_is_chalk/repl.html"><strong aria-hidden="true">1.3.</strong> REPL</a></li></ol></li><li class="chapter-item expanded "><a href="contribution_guide.html"><strong aria-hidden="true">2.</strong> Contribution guide</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Representing and manipulating types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/role_of_interner.html"><strong aria-hidden="true">3.1.</strong> The Interner</a></li><li class="chapter-item expanded "><a href="types/rust_types.html"><strong aria-hidden="true">3.2.</strong> Rust types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/rust_types/application_ty.html"><strong aria-hidden="true">3.2.1.</strong> Application types</a></li></ol></li><li class="chapter-item expanded "><a href="types/rust_lifetimes.html"><strong aria-hidden="true">3.3.</strong> Rust lifetimes</a></li><li class="chapter-item expanded "><a href="types/operations.html"><strong aria-hidden="true">3.4.</strong> Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/operations/fold.html"><strong aria-hidden="true">3.4.1.</strong> Fold and the Folder trait</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="clauses.html"><strong aria-hidden="true">4.</strong> Lowering Rust IR to logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="clauses/goals_and_clauses.html"><strong aria-hidden="true">4.1.</strong> Goals and clauses</a></li><li class="chapter-item expanded "><a href="clauses/type_equality.html"><strong aria-hidden="true">4.2.</strong> Type equality and unification</a></li><li class="chapter-item expanded "><a href="clauses/implied_bounds.html"><strong aria-hidden="true">4.3.</strong> Implied bounds</a></li><li class="chapter-item expanded "><a href="clauses/lowering_rules.html"><strong aria-hidden="true">4.4.</strong> Lowering rules</a></li><li class="chapter-item expanded "><a href="clauses/well_known_traits.html"><strong aria-hidden="true">4.5.</strong> Well known traits</a></li><li class="chapter-item expanded "><a href="clauses/wf.html"><strong aria-hidden="true">4.6.</strong> Well-formedness checking</a></li></ol></li><li class="chapter-item expanded "><a href="canonical_queries.html"><strong aria-hidden="true">5.</strong> Canonical queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="canonical_queries/canonicalization.html"><strong aria-hidden="true">5.1.</strong> Canonicalization</a></li></ol></li><li class="chapter-item expanded "><a href="engine.html"><strong aria-hidden="true">6.</strong> Chalk engine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/major_concepts.html"><strong aria-hidden="true">6.1.</strong> Major concepts</a></li><li class="chapter-item expanded "><a href="engine/logic.html"><strong aria-hidden="true">6.2.</strong> Logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/logic/coinduction.html"><strong aria-hidden="true">6.2.1.</strong> Coinduction</a></li></ol></li><li class="chapter-item expanded "><a href="engine/slg.html"><strong aria-hidden="true">6.3.</strong> SLG Solver</a></li></ol></li><li class="chapter-item expanded "><a href="recursive.html"><strong aria-hidden="true">7.</strong> Chalk recursive solver</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recursive/stack.html"><strong aria-hidden="true">7.1.</strong> The stack</a></li><li class="chapter-item expanded "><a href="recursive/inductive_cycles.html"><strong aria-hidden="true">7.2.</strong> Inductive cycles</a></li><li class="chapter-item expanded "><a href="recursive/search_graph.html"><strong aria-hidden="true">7.3.</strong> The search graph and caching</a></li><li class="chapter-item expanded "><a href="recursive/coinduction.html"><strong aria-hidden="true">7.4.</strong> Coinduction</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="glossary.html">Appendix A: Glossary and terminology</a></li><li class="chapter-item expanded affix "><a href="bibliography.html">Appendix B: Bibliography</a></li><li class="chapter-item expanded affix "><a href="todo.html">Appendix C: Incomplete chapters</a></li><li class="chapter-item expanded affix "><a href="publishing.html">Appendix D: Publishing Chalk</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-chalk" id="what-is-chalk">What is Chalk?</a></h1>
<blockquote>
<p>Chalk is under heavy development, so if any of these links are broken or if
any of the information is inconsistent with the code or outdated, please
<a href="https://github.com/rust-lang/chalk/issues">open an issue</a> so we can fix it. If you are able to fix the
issue yourself, we would love your contribution!</p>
</blockquote>
<p>Chalk is a library that implements the Rust trait system. The implementation is
meant to be practical and usable, but also high-level enough to map easily to a
full specification. It is also meant to be an independent library that can be
integrated both into the main rustc compiler and also other programs and
contexts.</p>
<h2><a class="header" href="#high-level-view-of-how-chalk-works" id="high-level-view-of-how-chalk-works">High-level view of how chalk works</a></h2>
<pre class="mermaid">graph TD
    Query["Does `Vec&lt;u8>` implement `Debug`?"]
    HighLevelInfo["How is the trait `Debug` declared?"]
    Response["Yes, `Vec&lt;u8>` implements `Debug`."]
    Chalk
    Query --> Chalk
    HighLevelInfo --> Chalk
    Chalk --> Response
</pre>
<p>Chalk is designed to answer queries about traits, such as &quot;Does the type <code>Vec&lt;u8&gt;</code> implement <code>Debug</code>&quot;? (Yes!). It can in some cases give inference feedback, such as &quot;Is there a unique type <code>T</code> such that <code>str: AsRef&lt;T&gt;</code>&quot;? In that case, the answer might be &quot;Yes, <code>T = str</code>.&quot;</p>
<p>To do this, it takes as input key information about a Rust program, such as:</p>
<ul>
<li>For a given trait, what are its type parameters, where clauses, and associated items</li>
<li>For a given impl, what are the types that appear in the impl header</li>
<li>For a given struct, what are the types of its fields</li>
</ul>
<h2><a class="header" href="#chalk-works-by-converting-rust-goals-into-logical-inference-rules" id="chalk-works-by-converting-rust-goals-into-logical-inference-rules">Chalk works by converting Rust goals into logical inference rules</a></h2>
<p>Internally, Chalk works by converting the Rust-specific information, like traits
and impls, into <em>logical predicates</em>. This process is called &quot;lowering&quot;, and you
can learn more about in the <a href="./clauses.html"><em>Lowering to Logic</em></a> and
<a href="./clauses/lowering_rules.html"><em>Lowering Rules</em></a>) sections.</p>
<p>After lowering to logical predicates, Chalk then deploys a <em>logical solver</em> to
find the answer to the original query; this solver is similar to a Prolog
engine, though different in its particulars.</p>
<p>The following sequence diagram helps to illustrate the flow of information that occurs
when Chalk is solving a particular goal. It involves three participants:</p>
<ul>
<li>The <strong>host program</strong>, which might be rustc, rust-analyzer, or chalk's internal
testing harness. The host program, importantly, only thinks about things in
<strong>Rust terms</strong>, like traits and impls.</li>
<li>The <strong>chalk-solve</strong> crate, which converts between Rust terms and logical clauses.</li>
<li>The <strong>logic engine</strong> layer, which knows how to solve logical clauses but knows nothing specific to Rust.</li>
</ul>
<pre class="mermaid">sequenceDiagram
  participant rustc as host program
  participant chalkSolve as chalk-solve
  participant chalkEngine as logic engine
  rustc->>chalkSolve: Does Vec[u32] implement Debug?
  chalkSolve->>chalkEngine: (Vec[u32]: Debug)?
  chalkEngine->>chalkSolve: What clauses can I use?
  chalkSolve->>rustc: What is the definition of `Debug`?<br>(via RustIrDatabase)
  rustc-->>chalkSolve: `trait Debug { .. }`<br>(a TraitDatum)
  chalkSolve->>rustc: What impls are there for Vec?
  rustc-->>chalkSolve: `impl[T]: Debug] Debug for Vec[T]`<br>(an ImplDatum)
  Note right of chalkSolve: "lowers" rust <br>declarations to logic
  chalkSolve-->>chalkEngine: (Vec[T]: Debug) :- (T: Debug)
  chalkSolve-->>chalkEngine: ... and other clauses ...
  activate chalkEngine
  Note right of chalkEngine: explores each clause<br>to see if it works
  chalkEngine-->>chalkSolve: (Vec[u32]: Debug) is provable
  deactivate chalkEngine
  chalkSolve-->>rustc: Yes, Vec[u32] implements Debug
</pre>
<h2><a class="header" href="#chalk-repl" id="chalk-repl">Chalk repl</a></h2>
<p>In addition to being embedded into host programs, chalk also has its own testing
harness along with an associated REPL. This allows us to write unit tests that
use a &quot;Rust-like&quot; syntax. The REPL then makes it easy to experiment and get a
better feel for how chalk works. See the <a href="what_is_chalk/walkthrough.html">walkthrough</a> for more details.</p>
<h1><a class="header" href="#walkthrough" id="walkthrough">Walkthrough</a></h1>
<p>This section shows a sample session in the chalk repl, and then gives a tour
through the code to give you an idea of the phases involved.</p>
<pre><code class="language-rust ignore">?- program
Enter a program; press Ctrl-D when finished
| struct Foo { }
| struct Bar { }
| struct Vec&lt;T&gt; { }
| trait Clone { }
| impl&lt;T&gt; Clone for Vec&lt;T&gt; where T: Clone { }
| impl Clone for Foo { }

?- Vec&lt;Foo&gt;: Clone
Unique; substitution [], lifetime constraints []

?- Vec&lt;Bar&gt;: Clone
No possible solution.

?- exists&lt;T&gt; { Vec&lt;T&gt;: Clone }
Ambiguous; no inference guidance
</code></pre>
<p>You can see more examples of programs and queries in the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L115">unit
tests</a>.</p>
<p>Next we'll go through each stage required to produce the output above.</p>
<h3><a class="header" href="#parsing-a-hrefhttpsrust-langgithubiochalkchalk_parseindexhtmlchalk_parsea" id="parsing-a-hrefhttpsrust-langgithubiochalkchalk_parseindexhtmlchalk_parsea">Parsing (<a href="https://rust-lang.github.io/chalk/chalk_parse/index.html">chalk_parse</a>)</a></h3>
<p>Chalk is designed to be incorporated with the Rust compiler, so the syntax and
concepts it deals with heavily borrow from Rust. It is convenient for the sake
of testing to be able to run chalk on its own, so chalk includes a parser for a
Rust-like syntax. This syntax is orthogonal to the Rust AST and grammar. It is
not intended to look exactly like it or support the exact same syntax.</p>
<p>The parser takes that syntax and produces an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a>.
You can find the <a href="https://rust-lang.github.io/chalk/chalk_parse/ast/index.html">complete definition of the AST</a> in the source code.</p>
<p>The syntax contains things from Rust that we know and love, for example: traits,
impls, and struct definitions. Parsing is often the first &quot;phase&quot; of
transformation that a program goes through in order to become a format that
chalk can understand.</p>
<h3><a class="header" href="#rust-intermediate-representation-a-hrefhttpsrust-langgithubiochalkchalk_solverust_irindexhtmlchalk_solverust_ira" id="rust-intermediate-representation-a-hrefhttpsrust-langgithubiochalkchalk_solverust_irindexhtmlchalk_solverust_ira">Rust Intermediate Representation (<a href="https://rust-lang.github.io/chalk/chalk_solve/rust_ir/index.html">chalk_solve::rust_ir</a>)</a></h3>
<p>After getting the AST we convert it to a more convenient intermediate
representation called <code>chalk_rust_ir</code>. This is sort of
analogous to the <a href="https://rustc-dev-guide.rust-lang.org/hir.html">HIR</a> in Rust. The process of converting to IR is called
<em>lowering</em>.</p>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_integration/program/struct.Program.html"><code>chalk::program::Program</code></a> struct contains some &quot;rust things&quot;
but indexed and accessible in a different way. For example, if you have a
type like <code>Foo&lt;Bar&gt;</code>, we would represent <code>Foo</code> as a string in the AST but in
<code>chalk::program::Program</code>, we use numeric indices (<code>ItemId</code>).</p>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_solve/rust_ir/">IR source code</a> contains the complete definition.</p>
<h3><a class="header" href="#chalk-intermediate-representation-a-hrefhttpsrust-langgithubiochalkchalk_irindexhtmlchalk_ira" id="chalk-intermediate-representation-a-hrefhttpsrust-langgithubiochalkchalk_irindexhtmlchalk_ira">Chalk Intermediate Representation (<a href="https://rust-lang.github.io/chalk/chalk_ir/index.html">chalk_ir</a>)</a></h3>
<p>Once we have Rust IR it is time to convert it to &quot;program clauses&quot;. A
<a href="https://rust-lang.github.io/chalk/chalk_ir/struct.ProgramClause.html"><code>ProgramClause</code></a> is essentially one of the following:</p>
<ul>
<li>A <a href="https://github.com/rust-lang/chalk/blob/master/GLOSSARY.md#clause">clause</a> of the form <code>consequence :- conditions</code> where <code>:-</code> is read as
&quot;if&quot; and <code>conditions = cond1 &amp;&amp; cond2 &amp;&amp; ...</code></li>
<li>A universally quantified clause of the form
<code>forall&lt;T&gt; { consequence :- conditions }</code>
<ul>
<li><code>forall&lt;T&gt; { ... }</code> is used to represent <a href="https://en.wikipedia.org/wiki/Universal_quantification">universal quantification</a>. See the
section on <a href="what_is_chalk/../clauses.html#type-checking-generic-functions-beyond-horn-clauses">Lowering to logic</a> for more information.</li>
<li>A key thing to note about <code>forall</code> is that we don't allow you to &quot;quantify&quot;
over traits, only types and regions (lifetimes). That is, you can't make a
rule like <code>forall&lt;Trait&gt; { u32: Trait }</code> which would say &quot;<code>u32</code> implements
all traits&quot;. You can however say <code>forall&lt;T&gt; { T: Trait }</code> meaning &quot;<code>Trait</code>
is implemented by all types&quot;.</li>
<li><code>forall&lt;T&gt; { ... }</code> is represented in the code using the <a href="https://rust-lang.github.io/chalk/chalk_ir/struct.Binders.html"><code>Binders&lt;T&gt;</code>
struct</a>.</li>
</ul>
</li>
</ul>
<p><em>See also: <a href="what_is_chalk/../clauses/goals_and_clauses.html">Goals and Clauses</a></em></p>
<p>This is where we encode the rules of the trait system into logic. For
example, if we have the following Rust:</p>
<pre><code class="language-rust ignore">impl&lt;T: Clone&gt; Clone for Vec&lt;T&gt; {}
</code></pre>
<p>We generate the following program clause:</p>
<pre><code class="language-rust ignore">forall&lt;T&gt; { (Vec&lt;T&gt;: Clone) :- (T: Clone) }
</code></pre>
<p>This rule dictates that <code>Vec&lt;T&gt;: Clone</code> is only satisfied if <code>T: Clone</code> is also
satisfied (i.e. &quot;provable&quot;).</p>
<p>Similar to <a href="https://rust-lang.github.io/chalk/chalk_integration/program/struct.Program.html"><code>chalk::program::Program</code></a> which has &quot;rust-like
things&quot;, chalk_ir defines <a href="https://rust-lang.github.io/chalk/chalk_integration/program_environment/struct.ProgramEnvironment.html"><code>ProgramEnvironment</code></a> which is &quot;pure logic&quot;.
The main field in that struct is <code>program_clauses</code>, which contains the
<a href="https://rust-lang.github.io/chalk/chalk_ir/struct.ProgramClause.html"><code>ProgramClause</code></a>s generated by the rules module.</p>
<h3><a class="header" href="#rules-a-hrefhttpsrust-langgithubiochalkchalk_solveindexhtmlchalk_solvea" id="rules-a-hrefhttpsrust-langgithubiochalkchalk_solveindexhtmlchalk_solvea">Rules (<a href="https://rust-lang.github.io/chalk/chalk_solve/index.html">chalk_solve</a>)</a></h3>
<p>The <code>chalk_solve</code> crate (<a href="https://rust-lang.github.io/chalk/chalk_solve/index.html">source code</a>) defines the logic rules we
use for each item in the Rust IR. It works by iterating over every trait, impl,
etc. and emitting the rules that come from each one.</p>
<p><em>See also: <a href="what_is_chalk/../clauses/lowering_rules.html">Lowering Rules</a></em></p>
<h4><a class="header" href="#well-formedness-checks" id="well-formedness-checks">Well-formedness checks</a></h4>
<p>As part of lowering to logic, we also do some &quot;well formedness&quot; checks. See
the <a href="https://rust-lang.github.io/chalk/chalk_solve/wf/index.html"><code>chalk_solve::wf</code> source code</a> for where those are done.</p>
<p><em>See also: <a href="what_is_chalk/../clauses/wf.html">Well-formedness checking</a></em></p>
<h4><a class="header" href="#coherence" id="coherence">Coherence</a></h4>
<p>The method <code>CoherenceSolver::specialization_priorities</code> in the <code>coherence</code> module
(<a href="https://rust-lang.github.io/chalk/chalk_solve/coherence/index.html">source code</a>) checks &quot;coherence&quot;, which means that it
ensures that two impls of the same trait for the same type cannot exist.</p>
<h3><a class="header" href="#solver-a-hrefhttpsrust-langgithubiochalkchalk_solveindexhtmlchalk_solvea" id="solver-a-hrefhttpsrust-langgithubiochalkchalk_solveindexhtmlchalk_solvea">Solver (<a href="https://rust-lang.github.io/chalk/chalk_solve/index.html">chalk_solve</a>)</a></h3>
<p>Finally, when we've collected all the program clauses we care about, we want
to perform queries on it. The component that finds the answer to these
queries is called the <em>solver</em>.</p>
<p><em>See also: <a href="what_is_chalk/../engine/slg.html">The SLG Solver</a></em></p>
<h2><a class="header" href="#crates" id="crates">Crates</a></h2>
<p>Chalk's functionality is broken up into the following crates:</p>
<ul>
<li><a href="https://rust-lang.github.io/chalk/chalk_engine"><strong>chalk_engine</strong></a>: Defines the core <a href="what_is_chalk/../engine/slg.html">SLG solver</a>.</li>
<li><a href="https://rust-lang.github.io/chalk/chalk_ir/index.html"><strong>chalk_ir</strong></a>: Defines chalk's internal representation of
types, lifetimes, and goals.</li>
<li><a href="https://rust-lang.github.io/chalk/chalk_solve/index.html"><strong>chalk_solve</strong></a>: Combines <code>chalk_ir</code> and <code>chalk_engine</code>,
effectively, which implements logic rules converting <code>chalk_rust_ir</code> to
<code>chalk_ir</code>
<ul>
<li>Contains the <code>rust_ir</code> module, which defines the &quot;HIR-like&quot; Rust IR</li>
<li>Defines the <code>coherence</code> module, which implements coherence rules</li>
<li><a href="https://rust-lang.github.io/chalk/chalk_engine/context/index.html"><code>chalk_engine::context</code></a> provides the necessary hooks.</li>
</ul>
</li>
<li><a href="https://rust-lang.github.io/chalk/chalk_parse/index.html"><strong>chalk_parse</strong></a>: Defines the raw AST and a parser.</li>
<li><a href="https://rust-lang.github.io/chalk/chalk/index.html"><strong>chalk</strong></a>: Brings everything together. Defines the following
modules:
<ul>
<li><code>chalk::lowering</code>, which converts AST to <code>chalk_rust_ir</code></li>
<li>Also includes <a href="https://github.com/rust-lang/chalk/blob/master/src/main.rs">chalki</a>, chalk's REPL.</li>
</ul>
</li>
</ul>
<p><a href="https://github.com/rust-lang/chalk">Browse source code on GitHub</a></p>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>chalk has a test framework for lowering programs to logic, checking the
lowered logic, and performing queries on it. This is how we test the
implementation of chalk itself, and the viability of the <a href="what_is_chalk/../clauses/lowering_rules.html">lowering
rules</a>.</p>
<p>The main kind of tests in chalk are <strong>goal tests</strong>. They contain a program,
which is expected to lower to logic successfully, and a set of queries
(goals) along with the expected output. Here's an
<a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L115">example</a>. Since chalk's output can be quite long, goal
tests support specifying only a prefix of the output.</p>
<p><strong>Lowering tests</strong> check the stages that occur before we can issue queries
to the solver: the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/rust_ir/lowering/test.rs">lowering to chalk_rust_ir</a>, and the
<a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/rules/wf/test.rs#L1">well-formedness checks</a> that occur after that.</p>
<h3><a class="header" href="#testing-internals" id="testing-internals">Testing internals</a></h3>
<p>Goal tests use a <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L33"><code>test!</code> macro</a> that takes chalk's Rust-like
syntax and runs it through the full pipeline described above. The macro
ultimately calls the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L85"><code>solve_goal</code> function</a>.</p>
<p>Likewise, lowering tests use the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test_util.rs#L21-L54"><code>lowering_success!</code> and
<code>lowering_error!</code> macros</a>.</p>
<h2><a class="header" href="#more-resources" id="more-resources">More Resources</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/chalk">Chalk Source Code</a></li>
<li><a href="what_is_chalk/../glossary.html">Chalk Glossary</a></li>
</ul>
<h1><a class="header" href="#crate-breakdown" id="crate-breakdown">Crate breakdown</a></h1>
<p>Chalk is broken up into a number of crates. This chapter explains the
role of each crate. This crate structure helps to serve Chalk's two goals:</p>
<ul>
<li>To serve as the trait engine for compilers and tools like rustc and rust-analyzer</li>
<li>To be usable as a standalone REPL and testing harness</li>
</ul>
<h2><a class="header" href="#crates-for-embedding-chalk-into-other-programs" id="crates-for-embedding-chalk-into-other-programs">Crates for embedding chalk into other programs</a></h2>
<p>The following crates are &quot;public facing&quot; crates that you may use when embedding chalk into
other programs:</p>
<ul>
<li>The <code>chalk-solve</code> crate, which defines the IR representing Rust concepts like
traits and impls and the rules that translate Rust IR into logical predicates.</li>
<li>The <code>chalk-ir</code> crate, which defines the IR representing types and logical predicates.</li>
</ul>
<p>The following crate is an implementation detail, used internally by <code>chalk-solve</code>:</p>
<ul>
<li>The <code>chalk-engine</code> crate, which defines the actual engine that solves logical predicate. This
engine is quite general and not really specific to Rust.</li>
<li>The <code>chalk-derive</code> crate defines custom derives for the <code>chalk_ir::fold::Fold</code> trait and other
such things.</li>
</ul>
<h2><a class="header" href="#crates-for-standalone-repl-and-testing" id="crates-for-standalone-repl-and-testing">Crates for standalone REPL and testing</a></h2>
<p>The following crates are used to define the REPL and internal testing
harness. These crates build on the crates above. Essentially, they
define a kind of &quot;minimal embedding&quot; of chalk.</p>
<ul>
<li>The <code>chalk-parser</code> crate can parse Rust syntax to product an AST.</li>
<li>The <code>chalk-integration</code> crate can take that AST and use it to drive the
<code>chalk-solve</code> crate above. The AST is converted into Rust IR by a process
called &quot;lowering'.</li>
<li>Finally, the main <code>chalk</code> crate, along with the testing crate in the
<code>tests</code> directory, define the actual entry points.</li>
</ul>
<h2><a class="header" href="#the-chalk-solve-crate" id="the-chalk-solve-crate">The chalk-solve crate</a></h2>
<table><thead><tr><th>The <code>chalk-solve</code> crate</th><th></th></tr></thead><tbody>
<tr><td>Purpose:</td><td>to solve a given goal</td></tr>
<tr><td>Depends on IR:</td><td>chalk-ir and rust-ir</td></tr>
<tr><td>Context required:</td><td><code>RustIrDatabase</code></td></tr>
</tbody></table>
<p>The <code>chalk-solve</code> crate exposes a key type called <code>Solver</code>.  This is a
solver that, given a goal (expressed in chalk-ir) will solve the goal
and yield up a <code>Solution</code>. The solver caches intermediate data between
invocations, so solving the same goal twice in a row (or solving goals
with common subgoals) is faster.</p>
<p>The solver is configured by a type that implements the
<code>RustIrDatabase</code> trait. This trait contains some callbacks that
provide needed context for the solver -- notably, the solver can ask:</p>
<ul>
<li><strong>What are the program clauses that might solve given rule?</strong> This
is answered by the code in the chalk-solve crate.</li>
<li><strong>Is this trait coinductive?</strong> This is answered by the chalk-ir.</li>
</ul>
<h2><a class="header" href="#the-chalk-engine-crate" id="the-chalk-engine-crate">The chalk-engine crate</a></h2>
<table><thead><tr><th>The <code>chalk-engine</code> crate</th><th></th></tr></thead><tbody>
<tr><td>Purpose:</td><td>define the base solving strategy</td></tr>
<tr><td>IR:</td><td>none</td></tr>
<tr><td>Context required:</td><td><code>Context</code> trait</td></tr>
</tbody></table>
<p>For the purposes of chalk, the <code>chalk-engine</code> crate is effectively
encapsulated by <code>chalk-solve</code>.  It defines the base SLG engine. It is
written in a very generic style that knows next to nothing about Rust
itself. The engine can be configured via the traits defined in
<code>chalk_engine::context::Context</code>, which contain (for example)
associated types that define what a goal or clause is, as well as
functions that operate on those things.</p>
<h1><a class="header" href="#repl" id="repl">REPL</a></h1>
<p>There is a repl mainly for debugging purposes which can be run by <code>cargo run</code>. Some basic examples are in <a href="https://github.com/rust-lang/chalk/blob/master/libstd.chalk">libstd.chalk</a>:</p>
<pre><code class="language-bash">$ cargo run
?- load libstd.chalk
?- Vec&lt;Box&lt;i32&gt;&gt;: Clone
Unique; substitution [], lifetime constraints []
</code></pre>
<h1><a class="header" href="#contribution-guide" id="contribution-guide">Contribution guide</a></h1>
<p>Thank you for your interest in contributing to chalk! There are many ways to
contribute, and we appreciate all of them.</p>
<ul>
<li><a href="contribution_guide.html#bug-reports">Bug Reports</a></li>
<li><a href="contribution_guide.html#running-and-debugging">Running and Debugging</a></li>
<li><a href="contribution_guide.html#pull-requests">Pull Requests</a></li>
<li><a href="contribution_guide.html#writing-documentation">Writing Documentation</a></li>
</ul>
<p>If you'd like to contribute, consider joining the <a href="https://rust-lang.github.io/compiler-team/working-groups/traits/">Traits Working Group</a>.
We hang out on the <a href="https://rust-lang.zulipchat.com">rust-lang zulip</a> in the <a href="https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits">#wg-traits</a> stream.</p>
<p>As a reminder, all contributors are expected to follow our <a href="https://www.rust-lang.org/conduct.html">Code of Conduct</a>.</p>
<h2><a class="header" href="#bug-reports" id="bug-reports">Bug Reports</a></h2>
<p>While bugs are unfortunate, they're a reality in software. We can't fix what we
don't know about, so please report liberally. If you're not sure if something
is a bug or not, feel free to file a bug anyway.</p>
<p>If you have the chance, before reporting a bug, please search existing issues,
as it's possible that someone else has already reported your error. This doesn't
always work, and sometimes it's hard to know what to search for, so consider
this extra credit. We won't mind if you accidentally file a duplicate report.</p>
<p>Sometimes, a backtrace is helpful, and so including that is nice. To get
a backtrace, set the <code>RUST_BACKTRACE</code> environment variable to a value
other than <code>0</code>. The easiest way to do this is to invoke <code>chalk</code> like this:</p>
<pre><code class="language-bash">$ RUST_BACKTRACE=1 chalk ...
</code></pre>
<h2><a class="header" href="#running-and-debugging" id="running-and-debugging">Running and Debugging</a></h2>
<p>There is a repl mainly for debugging purposes which can be run by <code>cargo run</code>. Some basic examples are in <a href="https://github.com/rust-lang/chalk/blob/master/libstd.chalk">libstd.chalk</a>:</p>
<pre><code class="language-bash">$ cargo run
?- load libstd.chalk
?- Vec&lt;Box&lt;i32&gt;&gt;: Clone
Unique; substitution [], lifetime constraints []
</code></pre>
<p>More logging can be enabled by setting the <code>CHALK_DEBUG</code> environment variable. Set <code>CHALK_DEBUG=3</code> or <code>CHALK_DEBUG=info</code> to see <code>info!(...)</code> output, and <code>CHALK_DEBUG=4</code> or <code>CHALK_DEBUG=debug</code> to see <code>debug!(...)</code> output as well. In addition, logs may be filtered in a number of ways. The syntax for filtering logs is:</p>
<pre><code class="language-notrust"> target[span{field=value}]=level
</code></pre>
<p>(Note: all parts of the filter are optional )</p>
<p>In more detail, the filter may consist of:</p>
<ul>
<li>A target (location of origin)
<ul>
<li>For example setting <code>CHALK_DEBUG='chalk_solve::infer::unify'</code> will filter logs to show only output originating from <code>chalk_solve::infer::unify</code>.</li>
</ul>
</li>
<li>A span (name provided to the logging macros, for instance <code>unify_var_ty</code> in <code>debug_span!(&quot;unify_var_ty&quot;)</code>)
<ul>
<li>For example setting <code>CHALK_DEBUG='[unify_ty_ty]'</code> will show only logs where the span contains <code>unify_ty_ty</code>.</li>
</ul>
</li>
<li>A list of fields (variables recorded in the logs), for instance <code>ty</code> in <code>debug!(&quot;unify_var_ty&quot;, ?ty)</code> with values optionally specified
<ul>
<li>For example setting <code>CHALK_DEBUG='[{ty}]'</code> will show only logs which contain a variable <code>ty</code></li>
<li>Setting <code>CHALK_DEBUG='[{ty=Bar}]'</code> will show only logs which contain a variable <code>ty</code> with the value <code>Bar</code></li>
</ul>
</li>
<li>A maximum log level (one of <code>info</code>, <code>debug</code>, <code>trace</code>) which shows logs at or below the given level</li>
</ul>
<p>More documentation on the syntax and options can be found <a href="https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html#Directives">here</a>.</p>
<h2><a class="header" href="#pull-requests" id="pull-requests">Pull Requests</a></h2>
<p>Pull requests are the primary mechanism we use to change Rust. GitHub itself
has some <a href="https://help.github.com/articles/about-pull-requests/">great documentation</a> on using the Pull Request feature.
We use the &quot;fork and pull&quot; model <a href="https://help.github.com/articles/about-collaborative-development-models/">described here</a>, where
contributors push changes to their personal fork and create pull requests to
bring those changes into the source repository.</p>
<p>Please make pull requests against the <code>master</code> branch.</p>
<h2><a class="header" href="#writing-documentation" id="writing-documentation">Writing Documentation</a></h2>
<p>Documentation improvements are very welcome. Documentation pull requests
function in the same way as other pull requests.</p>
<p>You can find documentation style guidelines in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md#appendix-a-full-conventions-text">RFC 1574</a>.</p>
<h1><a class="header" href="#representing-and-manipulating-rust-types" id="representing-and-manipulating-rust-types">Representing and manipulating Rust types</a></h1>
<h2><a class="header" href="#intermediate-representations" id="intermediate-representations">Intermediate representations</a></h2>
<p>Intermediate representations (IR) are used to represent parts of Rust programs such as traits and impls.</p>
<p>Chalk contains three levels of IR:</p>
<ul>
<li>The <strong>AST</strong>. This is used purely for writing test cases
with a Rust-like syntax. This is consumed by <strong>lowering</strong> code, which
takes AST and products <strong>Rust IR</strong> (the next bullet point).</li>
<li>The <strong>Rust IR</strong>. This is a &quot;HIR-like&quot; notation that defines the
interesting properties of things like traits, impls, and structs.
It is an input to the <strong>rules</strong> code, which produces</li>
<li>The <strong>Chalk IR</strong>. This is most &quot;Prolog-like&quot; of the various IRs. It
contains the definition of <strong>types</strong> as well as prolog-like concepts
such as goals (things that must be proven true) and clauses (things
that are assumed to be true).</li>
</ul>
<h2><a class="header" href="#goal-of-the-chalk-ir-crate" id="goal-of-the-chalk-ir-crate">Goal of the chalk-ir crate</a></h2>
<p>To have an ergonomic, flexible library that can abstractly represent
Rust types and logical predicates. The library should be expose a
&quot;minimal&quot; set of types that is nonetheless able to capture the full
range of Rust types. &quot;Minimal&quot; here means that some of the surface
differences in Rust types -- e.g., the distinction between built-in
types like <code>u32</code> and user-defined types like a struct -- ought to be
minimized, so that code that works with these types (e.g., trait
solving) can focus on the most important differences.</p>
<h2><a class="header" href="#goal-support-embedding-and-a-variety-of-contexts" id="goal-support-embedding-and-a-variety-of-contexts">Goal: support embedding and a variety of contexts</a></h2>
<p>One of our goals is to create a type representation that can be
readily embedded into a variety of contexts. Most specifically, we
would like to be able to embed into rustc and rust-analyzer, and
permit those two projects to use distinct memory management
strategies. This is primarily achieved via the <code>Interner</code> trait.</p>
<p>Initially, at least in rustc, the goal is to be able to easily and
&quot;reasonably efficiently&quot; convert back and forth between rustc's native
type representation and chalk's representation. Once chalk's design
has stabilized, however, the goal would be for rustc to adopt this
format as its &quot;native&quot; representation.</p>
<p>Note that even if the chalk type library were used everywhere,
however, it would still be useful for rustc to be able to control the
memory management strategy. (In other words, different consumers might
wish to use it in different ways.)</p>
<h2><a class="header" href="#note-on-status" id="note-on-status">Note on status</a></h2>
<p>At the moment, this documentation is a &quot;proposal&quot;. That means that it
diverges in some places from what is actually implemented. It has also
not been thoroughly discussed by the Rust compiler team as a whole.</p>
<p>Here is a (partial) list of some things that have to be adapted in
Chalk as of today to match this document:</p>
<ul>
<li>Extract <code>TypeName</code> into something opaque to chalk-ir.</li>
<li>Dyn type equality should probably be driven by entailment.</li>
<li>Projections need to be renamed to aliases.</li>
<li>The variant we use for impl traits should be removed and folded into type aliases.</li>
<li>Remove placeholders and projection placeholders from apply and create placeholder types.</li>
<li>Move <code>Error</code> from a <code>TypeName</code> to its own variant.</li>
<li>Introduce <code>GeneratorWitness</code> into chalk</li>
<li>Complete transition from <code>ForAll</code> to <code>Fn</code> in chalk</li>
</ul>
<h2><a class="header" href="#the-role-of-the-interner" id="the-role-of-the-interner">The role of the <code>Interner</code></a></h2>
<p>Most everything in the IR is parameterized by the <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html"><code>Interner</code></a> trait:</p>
<pre><code class="language-rust ignore">trait Interner: Copy + Clone + Debug + Eq + Ord {
    ..
}
</code></pre>
<p>We'll go over the details later, but for now it suffices to say that
the interner is defined by the embedded and can be used to control
(to a certain extent) the actual representation of types, goals, and
other things in memory. For example, the <code>Interner</code> trait could be
used to intern all the types, as rustc does, or it could be used to
<code>Box</code> them instead, as the chalk testing harness currently does.</p>
<h3><a class="header" href="#controlling-representation-with-interner" id="controlling-representation-with-interner">Controlling representation with <code>Interner</code></a></h3>
<p>The purpose of the <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html"><code>Interner</code></a> trait is to give control over how
types and other bits of chalk-ir are represented in memory. This is
done via an &quot;indirection&quot; strategy. We'll explain that strategy here
in terms of <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> and <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TyData.html"><code>TyData</code></a>, the two types used to represent
Rust types, but the same pattern is repeated for many other things.</p>
<p>Types are represented by a <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty&lt;I&gt;</code></a> type and the <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TyData.html"><code>TyData&lt;I&gt;</code></a> enum.
There is no <em>direct</em> connection between them. The link is rather made
by the <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html"><code>Interner</code></a> trait, via the <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#associatedtype.InternedType"><code>InternedTy</code></a> associated type:</p>
<pre><code class="language-rust ignore">struct Ty&lt;I: Interner&gt;(I::InternedTy);
enum TyData&lt;I: Interner&gt; { .. }
</code></pre>
<p>The way this works is that the <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html"><code>Interner</code></a> trait has an associated
type <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#associatedtype.InternedType"><code>InternedTy</code></a> and two related methods, <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#tymethod.intern_ty"><code>intern_ty</code></a> and <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#tymethod.ty_data"><code>ty_data</code></a>:</p>
<pre><code class="language-rust ignore">trait Interner {
    type InternedTy;

    fn intern_ty(&amp;self, data: &amp;TyData&lt;Self&gt;) -&gt; Self::InternedTy;
    fn ty_data(data: &amp;Self::InternedTy) -&gt; &amp;TyData&lt;Self&gt;;
}
</code></pre>
<p>However, as a user you are not meant to use these directly. Rather,
they are encapsulated in methods on the <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> and <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TyData.html"><code>TyData</code></a> types:</p>
<pre><code class="language-rust ignore">impl&lt;I: Interner&gt; Ty&lt;I&gt; {
  fn data(&amp;self) -&gt; &amp;TyData&lt;I&gt; {
    I::lookup_ty(self)
  }
}
</code></pre>
<p>and</p>
<pre><code class="language-rust ignore">impl&lt;I: Interner&gt; TyData&lt;I&gt; {
  fn intern(&amp;self, i: &amp;I) -&gt; Ty&lt;I&gt; {
    Ty(i.intern_ty(self))
  }
}
</code></pre>
<p>Note that there is an assumption here that <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#tymethod.ty_data"><code>ty_data</code></a> needs no
context. This effectively constrains the <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#associatedtype.InternedType"><code>InternedTy</code></a> representation
to be a <code>Box</code> or <code>&amp;</code> type. To be more general, at the cost of some
convenience, we could make that a method as well, so that one would
invoke <code>ty.data(i)</code> instead of just <code>ty.data()</code>. This would permit us
to use (for example) integers to represent interned types, which might
be nice (e.g., to permit using generational indices).</p>
<h1><a class="header" href="#rust-types" id="rust-types">Rust types</a></h1>
<p>Rust types are represented by the <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> and <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TyData.html"><code>TyData</code></a> types.
You use <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> to represent &quot;some Rust type&quot;. But to actually inspect
what sort of type you have, you invoke the <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html#method.data"><code>data</code></a> method, which
returns a <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TyData.html"><code>TyData</code></a>. As described earlier, the actual in-memory
representation of types is controlled by the <a href="http://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html"><code>Interner</code></a> trait.</p>
<h2><a class="header" href="#the-tydata-variants-and-how-they-map-to-rust-syntax" id="the-tydata-variants-and-how-they-map-to-rust-syntax">The <code>TyData</code> variants and how they map to Rust syntax</a></h2>
<p>This section covers the variants we use to categorize types. We have
endeavored to create a breakdown that simplifies the Rust &quot;surface
syntax&quot; of types to their &quot;essence&quot;. In particular, the goal is to
group together types that are largely treated identically by the
system and to separate types when there are important semantic
differences in how they are handled.</p>
<table><thead><tr><th>Chalk variant</th><th>Example Rust types</th></tr></thead><tbody>
<tr><td><code>Apply</code></td><td><code>Vec&lt;u32&gt;</code>, <code>f32</code></td></tr>
<tr><td><code>Placeholder</code></td><td>how we represent <code>T</code> when type checking <code>fn foo&lt;T&gt;() { .. }</code></td></tr>
<tr><td><code>Dyn</code></td><td><code>dyn Trait</code></td></tr>
<tr><td><code>Fn</code></td><td><code>fn(&amp;u8)</code></td></tr>
<tr><td><code>Alias</code></td><td><code>&lt;T as Iterator&gt;::Item</code>, or the <code>Foo</code> in <code>type Foo = impl Trait</code> and <code>type Foo = u32</code></td></tr>
<tr><td><code>BoundVariable</code></td><td>an uninstantiated generic parameter like the <code>T</code> in <code>struct Foo&lt;T&gt;</code></td></tr>
</tbody></table>
<h2><a class="header" href="#justification-for-each-variant" id="justification-for-each-variant">Justification for each variant</a></h2>
<p>Each variant of <code>TyData</code> generally wraps a single struct, which
represents a type known to be of that particular variant. This section
goes through the variants in a bit more detail, and in particular
describes why each variant exists.</p>
<h3><a class="header" href="#application-types" id="application-types">Application types</a></h3>
<p>The <code>Apply</code> variant contains an <code>ApplicationTy</code>. These are kind of the
&quot;normal Rust types&quot;, like <code>Vec&lt;u32&gt;</code> or <code>f32</code>. They consist of a &quot;type
name&quot; (in our examples, <code>Vec</code> and <code>f32</code> respecively) and zero or more
generic arguments (respectively, <code>[u32]</code> and <code>[]</code>).</p>
<p>They are equal to other types (modulo aliases, see below) iff they
have the same &quot;type name&quot; and the generic arguments are
recursively equal</p>
<h3><a class="header" href="#placeholders" id="placeholders">Placeholders</a></h3>
<p>The <code>Placeholder</code> variant contains a <code>PlaceholderIndex</code> type. It
represents a generic type that is being treated abstractly or -- more
generally -- the result of a &quot;type function&quot; that cannot be
evaluated. For example, when typing the body of a generic function
like <code>fn foo&lt;T: Iterator&gt;</code>, the type <code>T</code> would be represented with a
placeholder. Similarly, in that same function, the associated type
<code>T::Item</code> might be represented with a placeholder.</p>
<p>Like application types, placeholder <em>types</em> are only known to be
equal.</p>
<p>However, we choose not to represent placeholder types as type names
because they need to be created during type unification and other
operations, and hence that would require treating <code>TypeName</code> less opaquely.</p>
<p>Moreover, when proving negative goals, e.g., <code>not { Implemented(T: Trait) }</code>, placeholders are treated quite differently from application
types, since they do not (in fact) represent a known type. When
solving negative goals, placeholderes are replaced with inference
variables -- the idea is that this goal is only true if there is <em>no
type</em> <code>T</code> that implements <code>Trait</code>. Therefore, if we can find no
answeres for <code>exists&lt;T&gt; { Implemented(T: Trait) }</code>, then we know that
the negation is true. (Note that this means that e.g. <code>forall&lt;X&gt; { X = i32 }</code> is false but so is <code>forall&lt;X&gt; { not { X = i32 } }</code>.)</p>
<h3><a class="header" href="#inference-variables" id="inference-variables">Inference variables</a></h3>
<p>The <code>InferenceVar</code> variant wraps an <code>InferenceVar</code> type.  This
represents a type whose value is being inferred. The value of an
inference variables may be &quot;known&quot; or &quot;not known&quot;, but that state is
stored externally, in the inference context (see the section on
inference below).</p>
<p>When equating, inference variables are treated specially in that they
become bound (or, if they have already been bound, they are replaced
with their value).</p>
<p>Inference variables are also integral to canonicalization and
other types.</p>
<h3><a class="header" href="#dyn-types" id="dyn-types">Dyn types</a></h3>
<p>The <code>Dyn</code> variant wraps a <code>DynTy</code> and represents a <code>dyn Trait</code>
type. In chalk, these are represented as an existential type where we
store the predicates that are known to be true. So a type like <code>dyn Write</code> would be represented as, effectively, an <code>exists&lt;T&gt; { T: Write }</code> type.</p>
<p>When equating, two <code>dyn P</code> and <code>dyn Q</code> types are equal if <code>P = Q</code> --
i.e., they have the same bounds. Note that -- for this purpose --
ordering of bounds is significant. That means that if you create a
<code>dyn Foo + Send</code> and a <code>dyn Send + Foo</code>, chalk would consider them
distinct types. The assumption is that bounds are ordered in some
canonical fashion somewhere else. This may want to change.</p>
<p>There are &quot;automatic&quot; rules for proving that <code>dyn P: P</code> and so forth, but
that is outside the scope of the chalk-ir crate.</p>
<h3><a class="header" href="#function-pointer-types" id="function-pointer-types">Function pointer types</a></h3>
<p>The <code>Fn</code> variant wraps a <code>FnTy</code> struct and represents a <code>fn()</code> type
(in other words, a function pointer). In some ways, fn types are like
application types, but with one crucial difference: they also contain
a <code>forall</code> binder that for lifetimes whose value is determined when
the function is called. Consider e.g. a type like <code>fn(&amp;u32)</code> or --
more explicitly -- <code>for&lt;'a&gt; fn(&amp;'a u32)</code>.</p>
<p>Two <code>Fn</code> types <code>A, B</code> are equal <code>A = B</code> if <code>A &lt;: B</code> and <code>B &lt;: A</code></p>
<p>Two <code>Fn</code> types <code>A, B</code> are subtypes <code>A &lt;: B</code> if</p>
<ul>
<li>After instantiating the lifetime parameters on <code>B</code> universally...
<ul>
<li>You can instantiate the lifetime parameters on <code>A</code> existentially...
<ul>
<li>And then you find that <code>P_B &lt;: P_A</code> for every parameter type <code>P</code> on <code>A</code> and <code>B</code> and
<code>R_A &lt;: R_B</code> for the return type <code>R</code> of <code>A</code> and <code>B</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>We currently handle type inference with a bit of a hack (same as
rustc); when relating a <code>Fn</code> type <code>F</code> to an unbounded type
variable <code>V</code>, we instantiate <code>V</code> with <code>F</code>.  But in practice
because of the above subtyping rules there are actually a range of
values that <code>V</code> could have and still be equal with <code>F</code>. This may
or may not be something to consider revisiting.</p>
<h3><a class="header" href="#generator-witness-types" id="generator-witness-types">Generator witness types</a></h3>
<p>The <code>GeneratorWitness</code> variant wraps a <code>GeneratorWitness</code> type.  These
witnesses represent the types that may be part of a generator
state. Unlike other types, witnesses include bound, existential
lifetimes, which refer to lifetimes within the suspended stack frame.
You can think of it as a type like <code>exists&lt;'a&gt; { (T...) }</code>.</p>
<p>Witnesses are very similar to an <code>Apply</code> type, but it has a binder for
the erased lifetime(s), which must be handled specifically in equating
and so forth. In many ways, witnesses are also quite similar to <code>Fn</code>
types, and it is not out of the question that these two could be
unified; however, they are quite distinct semantically and so that
would be an annoying mismatch in other parts of the system.
Witnesses are also similar to a <code>Dyn</code> type, in that they represent an
existential type, but in contrast to <code>Dyn</code>, what we know here is
not a <em>predicate</em> but rather some upper bound on the set of types
contained within.</p>
<h3><a class="header" href="#alias-types" id="alias-types">Alias types</a></h3>
<p>The <code>Alias</code> variant wraps an <code>AliasTy</code> and is used to represent some form of <em>type
alias</em>. These correspond to associated type projections like <code>&lt;T as Iterator&gt;::Item</code>
but also <code>impl Trait</code> types and named type aliases like <code>type Foo&lt;X&gt; = Vec&lt;X&gt;</code>.</p>
<p>Each alias has an alias id as well as parameters. Aliases effectively
represent a <em>type function</em>.</p>
<p>Aliases are quite special when equating types. In general, an alias
type <code>A</code> can also be equal to <em>any other type</em> <code>T</code> (<code>AliasEq</code>) if evaluating the
alias <code>A</code> yields <code>T</code>.</p>
<p>However, some alias types can also be instantiated as &quot;alias
placeholders&quot;. This occurs when the precise type of the alias is not
known, but we know that there is <em>some type</em> that it evaluates to (for
example, <code>&lt;T as Iterator&gt;::Item</code> might be treated opaquely as
<code>T::Item</code>; similarly <code>impl Trait</code> types are treated opaquely until the
latter phases of the compiler). Alias placeholders are not represented
with the <code>Alias</code> variant, but rather with the placeholder variant
described previously.</p>
<h3><a class="header" href="#bound-variables" id="bound-variables">Bound variables</a></h3>
<p>The <code>BoundVariable</code> variant represents some variable that is bound in
an outer term. For example, given a term like <code>forall&lt;X&gt; { Implemented(X: Trait) }</code>, the <code>X</code> is bound. Bound variables in chalk
(like rustc) use de bruijin indices (See below).</p>
<p>Bound variables are never directly equated, as any bound variables would have
been instantiated with either inference variables or placeholders.</p>
<p>They do appear in canonical forms and other terms that contain binders.</p>
<h3><a class="header" href="#error-types" id="error-types">Error types</a></h3>
<p>The <code>Error</code> variant represents a type that resulted from some
erroneous expression. Error types generally propagate eagerly in an
attempt to suppress nonsense errors that are derived by interactions
with buggy code.</p>
<p><code>Error</code> should be its own variant because most bits of code will want
to handle it somewhat specially -- e.g., maybe it can &quot;unify&quot; with any
other type without any effect, and so forth.</p>
<h2><a class="header" href="#mapping-to-rustc-types" id="mapping-to-rustc-types">Mapping to rustc types</a></h2>
<p>The rustc <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html"><code>TyKind</code></a> enum has a lot more variants than chalk. This
section describes how the rustc types can be mapped to chalk
types. The intention is that, at least when transitioning, rustc would
implement the <code>Interner</code> trait and would map from the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html"><code>TyKind</code></a>
enum to chalk's <code>TyData</code> on the fly, when <code>data()</code> is invoked.</p>
<p>This section describes how each of rustc's variants can be mapped to
Chalk variants.</p>
<table><thead><tr><th>rustc type</th><th>chalk variant (and some notes)</th></tr></thead><tbody>
<tr><td><code>Bool</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Char</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Int(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Uint(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Float(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Adt(_, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Foreign(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Str</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Array(_, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Slice(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>RawPtr(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Ref(_, _, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>FnDef(_, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>FnPtr(_, _)</code></td><td><code>Fn</code></td></tr>
<tr><td><code>Dynamic(_, _)</code></td><td><code>Dyn</code></td></tr>
<tr><td><code>Closure(_, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Generator(_, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>GeneratorWitness(_)</code></td><td><code>GeneratorWitness</code></td></tr>
<tr><td><code>Never</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Tuple(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Projection(_)</code></td><td><code>Alias</code></td></tr>
<tr><td><code>UnnormalizedProjection(_)</code></td><td>(see below)</td></tr>
<tr><td><code>Opaque(_, _)</code></td><td><code>Alias</code></td></tr>
<tr><td><code>Param(_)</code></td><td>XXX Placeholder?</td></tr>
<tr><td><code>Bound(_, _)</code></td><td><code>BoundVariable</code></td></tr>
<tr><td><code>Placeholder(_)</code></td><td><code>Placeholder</code></td></tr>
<tr><td><code>Infer(_)</code></td><td><code>InferenceVar</code></td></tr>
<tr><td><code>Error</code></td><td><code>Error</code></td></tr>
</tbody></table>
<h1><a class="header" href="#application-types-1" id="application-types-1">Application types</a></h1>
<p>An <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.ApplicationTy.html"><code>ApplicationTy</code></a> is kind of a &quot;normal Rust type&quot;, like
<code>Vec&lt;u32&gt;</code> or <code>f32</code>. Such types are only &quot;equal&quot; to themselves (modulo
aliases, see below), and they may take type arguments.  Note that we
group together <em>both</em> user-defined structs/enums/unions (like <code>Vec</code>)
as well as built-in types like <code>f32</code>, which effectively behave the
same.</p>
<p>An <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.ApplicationTy.html"><code>ApplicationTy</code></a> contains two fields:</p>
<ul>
<li>a &quot;type name&quot; (of type <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TypeName.html"><code>TypeName</code></a>); and,</li>
<li>a list of generic arguments (of type <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Substitution.html"><code>Substitution</code></a>).</li>
</ul>
<p>The <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TypeName.html"><code>TypeName</code></a> itself is largely opaque to chalk. We discuss it in
more detail elsewhere. The point is that it represents, semantically,
either the name of some user-defined type (like <code>Vec</code>) or builtin-types
like <code>i32</code>. It may also represent types like &quot;tuple of arity 2&quot; (<code>(_, _)</code>) or &quot;fixed-length array&quot; <code>[_; _]</code>. Note that the precise set of
these built-in types is defined by the <code>Interner</code> and is unknown to
chalk-ir.</p>
<h1><a class="header" href="#rust-lifetimes" id="rust-lifetimes">Rust lifetimes</a></h1>
<p>Lifetimes are represented by the <code>Lifetime&lt;I&gt;</code> and <code>LifetimeData&lt;I&gt;</code>
types. As with types, the actual representation of a lifetime is
defined by the associated type <code>I::InternedLifetime</code>.</p>
<h3><a class="header" href="#the-lifetimedata-variants" id="the-lifetimedata-variants">The <code>LifetimeData</code> variants</a></h3>
<p>This section covers the variants we use to categorize lifetimes.</p>
<h4><a class="header" href="#variants-and-their-equivalents-in-rust-syntax" id="variants-and-their-equivalents-in-rust-syntax">Variants and their equivalents in Rust syntax</a></h4>
<table><thead><tr><th>Chalk variant</th><th>Example Rust types</th></tr></thead><tbody>
<tr><td><code>BoundVar</code></td><td>the <code>'a</code> in a type like <code>for&lt;'a&gt; fn(&amp;'a u8)</code>, before it is instantiated</td></tr>
<tr><td><code>InferenceVar</code></td><td>a lifetime whose value is being inferred</td></tr>
<tr><td><code>Placeholder</code></td><td>how we represent <code>'a</code> when type checking <code>fn foo&lt;'a&gt;() { .. }</code></td></tr>
<tr><td><code>Static</code></td><td>the lifetime <code>'static</code></td></tr>
</tbody></table>
<h1><a class="header" href="#operations" id="operations">Operations</a></h1>
<p>This chapter describes various patterns and utilities for manipulating
Rust types.</p>
<h1><a class="header" href="#fold-and-the-folder-trait" id="fold-and-the-folder-trait">Fold and the Folder trait</a></h1>
<p>The <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html"><code>Fold</code></a> trait permits one to traverse a type or other term in the
chalk-ir and make a copy of it, possibly making small substitutions or
alterations along the way. Folding also allows copying a term from one
interner to another.</p>
<p>To use the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html"><code>Fold</code></a> trait, one invokes the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html#tymethod.fold_with"><code>Fold::fold_with</code></a> method, supplying some
&quot;folder&quot; as well as the number of &quot;in scope binders&quot; for that term (typically <code>0</code>
to start):</p>
<pre><code class="language-rust ignore">let output_ty = input_ty.fold_with(&amp;mut folder, 0);
</code></pre>
<p>The folder is some instance of the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html"><code>Folder</code></a> trait. This trait
defines a few key callbacks that allow you to substitute different
values as the fold proceeds. For example, when a type is folded, the
folder can substitute a new type in its place.</p>
<h2><a class="header" href="#uses-for-folders" id="uses-for-folders">Uses for folders</a></h2>
<p>A common use for <code>Fold</code> is to permit a substitution -- that is,
replacing generic type parameters with their values.</p>
<h2><a class="header" href="#from-fold-to-folder-to-superfold-and-back-again" id="from-fold-to-folder-to-superfold-and-back-again">From Fold to Folder to SuperFold and back again</a></h2>
<p>The overall flow of folding is like this.</p>
<ol>
<li><a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html#tymethod.fold_with"><code>Fold::fold_with</code></a> is invoked on the outermost term. It recursively
walks the term.</li>
<li>For those sorts of terms (types, lifetimes, goals, program clauses) that have
callbacks in the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html"><code>Folder</code></a> trait, invoking <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html#tymethod.fold_with"><code>Fold::fold_with</code></a> will in turn
invoke the corresponding method on the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html"><code>Folder</code></a> trait, such as <code>Folder::fold_ty</code>.</li>
<li>The default implementation of <code>Folder::fold_ty</code>, in turn, invokes
<code>SuperFold::super_fold_with</code>.  This will recursively fold the
contents of the type. In some cases, the <code>super_fold_with</code>
implementation invokes more specialized methods on <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html"><code>Folder</code></a>, such
as <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html#method.fold_free_var_ty"><code>Folder::fold_free_var_ty</code></a>, which makes it easier to write
folders that just intercept <em>certain</em> types.</li>
</ol>
<p>Thus, as a user, you can customize folding by:</p>
<ul>
<li>Defining your own <code>Folder</code> type</li>
<li>Implementing the appropriate methods to &quot;intercept&quot; types/lifetimes/etc at the right level of
detail</li>
<li>In those methods, if you find a case where you would prefer not to
substitute a new value, then invoke <code>SuperFold::super_fold_with</code> to
return to the default behavior.</li>
</ul>
<h2><a class="header" href="#the-binders-argument" id="the-binders-argument">The <code>binders</code> argument</a></h2>
<p>Each callback in the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html"><code>Folder</code></a> trait takes a <code>binders</code> argument. This indicates
the number of binders that we have traversed during folding, which is relevant for debruijn indices.
So e.g. a bound variable with depth 1, if invoked with a <code>binders</code> value of 1, indicates something that was bound to something external to the fold.</p>
<p>XXX explain with examples and in more detail</p>
<h2><a class="header" href="#the-foldresult-associated-type" id="the-foldresult-associated-type">The <code>Fold::Result</code> associated type</a></h2>
<p>The <code>Fold</code> trait defines a <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html#associatedtype.Result"><code>Result</code></a> associated type, indicating the
type that will result from folding.</p>
<h2><a class="header" href="#when-to-implement-the-fold-and-superfold-traits" id="when-to-implement-the-fold-and-superfold-traits">When to implement the Fold and SuperFold traits</a></h2>
<p>Any piece of IR that represents a kind of &quot;term&quot; (e.g., a type, part
of a type, or a goal, etc) in the logic should implement <code>Fold</code>. We
also implement <code>Fold</code> for common collection types like <code>Vec</code> as well
as tuples, references, etc.</p>
<p>The <code>SuperFold</code> trait should only be implemented for those types that
have a callback defined on the <code>Folder</code> trait (e.g., types and
lifetimes).</p>
<h2><a class="header" href="#derives" id="derives">Derives</a></h2>
<p>Using the <code>chalk-derive</code> crate, you can auto-derive the <code>Fold</code> trait.
There isn't presently a derive for <code>SuperFold</code> since it is very rare
to require it. The derive for <code>Fold</code> is a bit cludgy and requires:</p>
<ul>
<li>You must import <code>Fold</code> into scope.</li>
<li>The type you are deriving <code>Fold</code> on must have either:
<ul>
<li>A type parameter that has a <code>Interner</code> bound, like <code>I: Interner</code></li>
<li>A type parameter that has a <code>HasInterner</code> bound, like <code>I: HasInterner</code></li>
<li>The <code>has_interner(XXX)</code> attribute.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#lowering-rust-ir-to-logic" id="lowering-rust-ir-to-logic">Lowering Rust IR to logic</a></h1>
<p>The key observation here is that the Rust trait system is basically a
kind of logic, and it can be mapped onto standard logical inference
rules. We can then look for solutions to those inference rules in a
very similar fashion to how e.g. a <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a> solver works. It turns out
that we can't <em>quite</em> use Prolog rules (also called Horn clauses) but
rather need a somewhat more expressive variant.</p>
<h2><a class="header" href="#rust-traits-and-logic" id="rust-traits-and-logic">Rust traits and logic</a></h2>
<p>One of the first observations is that the Rust trait system is
basically a kind of logic. As such, we can map our struct, trait, and
impl declarations into logical inference rules. For the most part,
these are basically Horn clauses, though we'll see that to capture the
full richness of Rust – and in particular to support generic
programming – we have to go a bit further than standard Horn clauses.</p>
<p>To see how this mapping works, let's start with an example. Imagine
we declare a trait and a few impls, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Clone { }
impl Clone for usize { }
impl&lt;T&gt; Clone for Vec&lt;T&gt; where T: Clone { }
<span class="boring">}
</span></code></pre></pre>
<p>We could map these declarations to some Horn clauses, written in a
Prolog-like notation, as follows:</p>
<pre><code class="language-text">Clone(usize).
Clone(Vec&lt;?T&gt;) :- Clone(?T).

// The notation `A :- B` means &quot;A is true if B is true&quot;.
// Or, put another way, B implies A.
</code></pre>
<p>In Prolog terms, we might say that <code>Clone(Foo)</code> – where <code>Foo</code> is some
Rust type – is a <em>predicate</em> that represents the idea that the type
<code>Foo</code> implements <code>Clone</code>. These rules are <strong>program clauses</strong>; they
state the conditions under which that predicate can be proven (i.e.,
considered true). So the first rule just says &quot;Clone is implemented
for <code>usize</code>&quot;. The next rule says &quot;for any type <code>?T</code>, Clone is
implemented for <code>Vec&lt;?T&gt;</code> if clone is implemented for <code>?T</code>&quot;. So
e.g. if we wanted to prove that <code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code>, we would do
so by applying the rules recursively:</p>
<ul>
<li><code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code> is provable if:
<ul>
<li><code>Clone(Vec&lt;usize&gt;)</code> is provable if:
<ul>
<li><code>Clone(usize)</code> is provable. (Which it is, so we're all good.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>But now suppose we tried to prove that <code>Clone(Vec&lt;Bar&gt;)</code>. This would
fail (after all, I didn't give an impl of <code>Clone</code> for <code>Bar</code>):</p>
<ul>
<li><code>Clone(Vec&lt;Bar&gt;)</code> is provable if:
<ul>
<li><code>Clone(Bar)</code> is provable. (But it is not, as there are no applicable rules.)</li>
</ul>
</li>
</ul>
<p>We can easily extend the example above to cover generic traits with
more than one input type. So imagine the <code>Eq&lt;T&gt;</code> trait, which declares
that <code>Self</code> is equatable with a value of type <code>T</code>:</p>
<pre><code class="language-rust ignore">trait Eq&lt;T&gt; { ... }
impl Eq&lt;usize&gt; for usize { }
impl&lt;T: Eq&lt;U&gt;&gt; Eq&lt;Vec&lt;U&gt;&gt; for Vec&lt;T&gt; { }
</code></pre>
<p>That could be mapped as follows:</p>
<pre><code class="language-text">Eq(usize, usize).
Eq(Vec&lt;?T&gt;, Vec&lt;?U&gt;) :- Eq(?T, ?U).
</code></pre>
<p>So far so good.</p>
<h2><a class="header" href="#type-checking-normal-functions" id="type-checking-normal-functions">Type-checking normal functions</a></h2>
<p>OK, now that we have defined some logical rules that are able to
express when traits are implemented and to handle associated types,
let's turn our focus a bit towards <strong>type-checking</strong>. Type-checking is
interesting because it is what gives us the goals that we need to
prove. That is, everything we've seen so far has been about how we
derive the rules by which we can prove goals from the traits and impls
in the program; but we are also interested in how to derive the goals
that we need to prove, and those come from type-checking.</p>
<p>Consider type-checking the function <code>foo()</code> here:</p>
<pre><code class="language-rust ignore">fn foo() { bar::&lt;usize&gt;() }
fn bar&lt;U: Eq&lt;U&gt;&gt;() { }
</code></pre>
<p>This function is very simple, of course: all it does is to call
<code>bar::&lt;usize&gt;()</code>. Now, looking at the definition of <code>bar()</code>, we can see
that it has one where-clause <code>U: Eq&lt;U&gt;</code>. So, that means that <code>foo()</code> will
have to prove that <code>usize: Eq&lt;usize&gt;</code> in order to show that it can call <code>bar()</code>
with <code>usize</code> as the type argument.</p>
<p>If we wanted, we could write a Prolog predicate that defines the
conditions under which <code>bar()</code> can be called. We'll say that those
conditions are called being &quot;well-formed&quot;:</p>
<pre><code class="language-text">barWellFormed(?U) :- Eq(?U, ?U).
</code></pre>
<p>Then we can say that <code>foo()</code> type-checks if the reference to
<code>bar::&lt;usize&gt;</code> (that is, <code>bar()</code> applied to the type <code>usize</code>) is
well-formed:</p>
<pre><code class="language-text">fooTypeChecks :- barWellFormed(usize).
</code></pre>
<p>If we try to prove the goal <code>fooTypeChecks</code>, it will succeed:</p>
<ul>
<li><code>fooTypeChecks</code> is provable if:
<ul>
<li><code>barWellFormed(usize)</code>, which is provable if:
<ul>
<li><code>Eq(usize, usize)</code>, which is provable because of an impl.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Ok, so far so good. Let's move on to type-checking a more complex function.</p>
<h2><a class="header" href="#type-checking-generic-functions-beyond-horn-clauses" id="type-checking-generic-functions-beyond-horn-clauses">Type-checking generic functions: beyond Horn clauses</a></h2>
<p>In the last section, we used standard Prolog horn-clauses (augmented with Rust's
notion of type equality) to type-check some simple Rust functions. But that only
works when we are type-checking non-generic functions. If we want to type-check
a generic function, it turns out we need a stronger notion of goal than what Prolog
can provide. To see what I'm talking about, let's revamp our previous
example to make <code>foo</code> generic:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Eq&lt;T&gt;&gt;() { bar::&lt;T&gt;() }
fn bar&lt;U: Eq&lt;U&gt;&gt;() { }
</code></pre>
<p>To type-check the body of <code>foo</code>, we need to be able to hold the type
<code>T</code> &quot;abstract&quot;.  That is, we need to check that the body of <code>foo</code> is
type-safe <em>for all types <code>T</code></em>, not just for some specific type. We might express
this like so:</p>
<pre><code class="language-text">fooTypeChecks :-
  // for all types T...
  forall&lt;T&gt; {
    // ...if we assume that Eq(T, T) is provable...
    if (Eq(T, T)) {
      // ...then we can prove that `barWellFormed(T)` holds.
      barWellFormed(T)
    }
  }.
</code></pre>
<p>This notation I'm using here is the notation I've been using in my
prototype implementation; it's similar to standard mathematical
notation but a bit Rustified. Anyway, the problem is that standard
Horn clauses don't allow universal quantification (<code>forall</code>) or
implication (<code>if</code>) in goals (though many Prolog engines do support
them, as an extension). For this reason, we need to accept something
called &quot;first-order hereditary harrop&quot; (FOHH) clauses – this long
name basically means &quot;standard Horn clauses with <code>forall</code> and <code>if</code> in
the body&quot;. But it's nice to know the proper name, because there is a
lot of work describing how to efficiently handle FOHH clauses; see for
example Gopalan Nadathur's excellent
<a href="./bibliography.html#pphhf">&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a>
in <a href="./bibliography.html">the bibliography</a>.</p>
<p>It turns out that supporting FOHH is not really all that hard. And
once we are able to do that, we can easily describe the type-checking
rule for generic functions like <code>foo</code> in our logic.</p>
<h2><a class="header" href="#source" id="source">Source</a></h2>
<p>This page is a lightly adapted version of a
<a href="http://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/">blog post by Nicholas Matsakis</a>.</p>
<h1><a class="header" href="#goals-and-clauses" id="goals-and-clauses">Goals and clauses</a></h1>
<p>In logic programming terms, a <strong>goal</strong> is something that you must
prove and a <strong>clause</strong> is something that you know is true. As
described in the <a href="clauses/../clauses.html">lowering to logic</a>
chapter, Rust's trait solver is based on an extension of hereditary
harrop (HH) clauses, which extend traditional Prolog Horn clauses with
a few new superpowers.</p>
<h2><a class="header" href="#goals-and-clauses-meta-structure" id="goals-and-clauses-meta-structure">Goals and clauses meta structure</a></h2>
<p>In Rust's solver, <strong>goals</strong> and <strong>clauses</strong> have the following forms
(note that the two definitions reference one another):</p>
<pre><code class="language-text">Goal = DomainGoal           // defined in the section below
        | Goal &amp;&amp; Goal
        | Goal || Goal
        | exists&lt;K&gt; { Goal }   // existential quantification
        | forall&lt;K&gt; { Goal }   // universal quantification
        | if (Clause) { Goal } // implication
        | true                 // something that's trivially true
        | ambiguous            // something that's never provable

Clause = DomainGoal
        | Clause :- Goal     // if can prove Goal, then Clause is true
        | Clause &amp;&amp; Clause
        | forall&lt;K&gt; { Clause }

K = &lt;type&gt;     // a &quot;kind&quot;
    | &lt;lifetime&gt;
</code></pre>
<p>The proof procedure for these sorts of goals is actually quite
straightforward.  Essentially, it's a form of depth-first search. The
paper
<a href="clauses/../bibliography.html#pphhf">&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a>
gives the details.</p>
<p>In terms of code, these types are defined in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_middle/traits/mod.rs"><code>librustc_middle/traits/mod.rs</code></a> in rustc, and in
<a href="https://github.com/rust-lang/chalk/blob/master/chalk-ir/src/lib.rs"><code>chalk-ir/src/lib.rs</code></a> in chalk.</p>
<p><a name="domain-goals"></a></p>
<h2><a class="header" href="#domain-goals" id="domain-goals">Domain goals</a></h2>
<p><em>Domain goals</em> are the atoms of the trait logic. As can be seen in the
definitions given above, general goals basically consist in a combination of
domain goals.</p>
<p>Moreover, flattening a bit the definition of clauses given previously, one can
see that clauses are always of the form:</p>
<pre><code class="language-text">forall&lt;K1, ..., Kn&gt; { DomainGoal :- Goal }
</code></pre>
<p>hence domain goals are in fact clauses' LHS. That is, at the most granular level,
domain goals are what the trait solver will end up trying to prove.</p>
<p><a name="trait-ref"></a></p>
<p>To define the set of domain goals in our system, we need to first
introduce a few simple formulations. A <strong>trait reference</strong> consists of
the name of a trait along with a suitable set of inputs P0..Pn:</p>
<pre><code class="language-text">TraitRef = P0: TraitName&lt;P1..Pn&gt;
</code></pre>
<p>So, for example, <code>u32: Display</code> is a trait reference, as is <code>Vec&lt;T&gt;: IntoIterator</code>. Note that Rust surface syntax also permits some extra
things, like associated type bindings (<code>Vec&lt;T&gt;: IntoIterator&lt;Item = T&gt;</code>), that are not part of a trait reference.</p>
<p><a name="projection"></a></p>
<p>A <strong>projection</strong> consists of an associated item reference along with
its inputs P0..Pm:</p>
<pre><code class="language-text">Projection = &lt;P0 as TraitName&lt;P1..Pn&gt;&gt;::AssocItem&lt;Pn+1..Pm&gt;
</code></pre>
<p>Given these, we can define a <code>DomainGoal</code> as follows:</p>
<pre><code class="language-text">DomainGoal = Holds(WhereClause)
            | FromEnv(TraitRef)
            | FromEnv(Type)
            | WellFormed(TraitRef)
            | WellFormed(Type)
            | Normalize(Projection -&gt; Type)

WhereClause = Implemented(TraitRef)
            | ProjectionEq(Projection = Type)
            | Outlives(Type: Region)
            | Outlives(Region: Region)
</code></pre>
<p><code>WhereClause</code> refers to a <code>where</code> clause that a Rust user would actually be able
to write in a Rust program. This abstraction exists only as a convenience as we
sometimes want to only deal with domain goals that are effectively writable in
Rust.</p>
<p>Let's break down each one of these, one-by-one.</p>
<h4><a class="header" href="#implementedtraitref" id="implementedtraitref">Implemented(TraitRef)</a></h4>
<p>e.g. <code>Implemented(i32: Copy)</code></p>
<p>True if the given trait is implemented for the given input types and lifetimes.</p>
<h4><a class="header" href="#projectioneqprojection--type" id="projectioneqprojection--type">ProjectionEq(Projection = Type)</a></h4>
<p>e.g. <code>ProjectionEq&lt;T as Iterator&gt;::Item = u8</code></p>
<p>The given associated type <code>Projection</code> is equal to <code>Type</code>; this can be proved
with either normalization or using placeholder associated types. See
<a href="clauses/./type_equality.html">the section on associated types</a>.</p>
<h4><a class="header" href="#normalizeprojection---type" id="normalizeprojection---type">Normalize(Projection -&gt; Type)</a></h4>
<p>e.g. <code>ProjectionEq&lt;T as Iterator&gt;::Item -&gt; u8</code></p>
<p>The given associated type <code>Projection</code> can be <a href="clauses/./type_equality.html#normalize">normalized</a> to <code>Type</code>.</p>
<p>As discussed in <a href="clauses/./type_equality.html">the section on associated
types</a>, <code>Normalize</code> implies <code>ProjectionEq</code>,
but not vice versa. In general, proving <code>Normalize(&lt;T as Trait&gt;::Item -&gt; U)</code>
also requires proving <code>Implemented(T: Trait)</code>.</p>
<h4><a class="header" href="#fromenvtraitref" id="fromenvtraitref">FromEnv(TraitRef)</a></h4>
<p>e.g. <code>FromEnv(Self: Add&lt;i32&gt;)</code></p>
<p>True if the inner <code>TraitRef</code> is <em>assumed</em> to be true,
that is, if it can be derived from the in-scope where clauses.</p>
<p>For example, given the following function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn loud_clone&lt;T: Clone&gt;(stuff: &amp;T) -&gt; T {
    println!(&quot;cloning!&quot;);
    stuff.clone()
}
<span class="boring">}
</span></code></pre></pre>
<p>Inside the body of our function, we would have <code>FromEnv(T: Clone)</code>. In-scope
where clauses nest, so a function body inside an impl body inherits the
impl body's where clauses, too.</p>
<p>This and the next rule are used to implement <a href="clauses/./lowering_rules.html#implied-bounds">implied bounds</a>. As we'll see
in the section on lowering, <code>FromEnv(TraitRef)</code> implies <code>Implemented(TraitRef)</code>,
but not vice versa. This distinction is crucial to implied bounds.</p>
<h4><a class="header" href="#fromenvtype" id="fromenvtype">FromEnv(Type)</a></h4>
<p>e.g. <code>FromEnv(HashSet&lt;K&gt;)</code></p>
<p>True if the inner <code>Type</code> is <em>assumed</em> to be well-formed, that is, if it is an
input type of a function or an impl.</p>
<p>For example, given the following code:</p>
<pre><code class="language-rust ignore">struct HashSet&lt;K&gt; where K: Hash { ... }

fn loud_insert&lt;K&gt;(set: &amp;mut HashSet&lt;K&gt;, item: K) {
    println!(&quot;inserting!&quot;);
    set.insert(item);
}
</code></pre>
<p><code>HashSet&lt;K&gt;</code> is an input type of the <code>loud_insert</code> function. Hence, we assume it
to be well-formed, so we would have <code>FromEnv(HashSet&lt;K&gt;)</code> inside the body of our
function. As we'll see in the section on lowering, <code>FromEnv(HashSet&lt;K&gt;)</code> implies
<code>Implemented(K: Hash)</code> because the
<code>HashSet</code> declaration was written with a <code>K: Hash</code> where clause. Hence, we don't
need to repeat that bound on the <code>loud_insert</code> function: we rather automatically
assume that it is true.</p>
<h4><a class="header" href="#wellformeditem" id="wellformeditem">WellFormed(Item)</a></h4>
<p>These goals imply that the given item is <em>well-formed</em>.</p>
<p>We can talk about different types of items being well-formed:</p>
<ul>
<li>
<p><em>Types</em>, like <code>WellFormed(Vec&lt;i32&gt;)</code>, which is true in Rust, or
<code>WellFormed(Vec&lt;str&gt;)</code>, which is not (because <code>str</code> is not <code>Sized</code>.)</p>
</li>
<li>
<p><em>TraitRefs</em>, like <code>WellFormed(Vec&lt;i32&gt;: Clone)</code>.</p>
</li>
</ul>
<p>Well-formedness is important to <a href="clauses/./lowering_rules.html#implied-bounds">implied bounds</a>. In particular, the reason
it is okay to assume <code>FromEnv(T: Clone)</code> in the <code>loud_clone</code> example is that we
<em>also</em> verify <code>WellFormed(T: Clone)</code> for each call site of <code>loud_clone</code>.
Similarly, it is okay to assume <code>FromEnv(HashSet&lt;K&gt;)</code> in the <code>loud_insert</code>
example because we will verify <code>WellFormed(HashSet&lt;K&gt;)</code> for each call site of
<code>loud_insert</code>. </p>
<h4><a class="header" href="#outlivestype-region-outlivesregion-region" id="outlivestype-region-outlivesregion-region">Outlives(Type: Region), Outlives(Region: Region)</a></h4>
<p>e.g. <code>Outlives(&amp;'a str: 'b)</code>, <code>Outlives('a: 'static)</code></p>
<p>True if the given type or region on the left outlives the right-hand region.</p>
<p><a name="coinductive"></a></p>
<h2><a class="header" href="#coinductive-goals" id="coinductive-goals">Coinductive goals</a></h2>
<p>Most goals in our system are &quot;inductive&quot;. In an inductive goal,
circular reasoning is disallowed. Consider this example clause:</p>
<pre><code class="language-text">    Implemented(Foo: Bar) :-
        Implemented(Foo: Bar).
</code></pre>
<p>Considered inductively, this clause is useless: if we are trying to
prove <code>Implemented(Foo: Bar)</code>, we would then recursively have to prove
<code>Implemented(Foo: Bar)</code>, and that cycle would continue ad infinitum
(the trait solver will terminate here, it would just consider that
<code>Implemented(Foo: Bar)</code> is not known to be true).</p>
<p>However, some goals are <em>co-inductive</em>. Simply put, this means that
cycles are OK. So, if <code>Bar</code> were a co-inductive trait, then the rule
above would be perfectly valid, and it would indicate that
<code>Implemented(Foo: Bar)</code> is true.</p>
<p><em>Auto traits</em> are one example in Rust where co-inductive goals are used.
Consider the <code>Send</code> trait, and imagine that we have this struct:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Foo {
    next: Option&lt;Box&lt;Foo&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>The default rules for auto traits say that <code>Foo</code> is <code>Send</code> if the
types of its fields are <code>Send</code>. Therefore, we would have a rule like</p>
<pre><code class="language-text">Implemented(Foo: Send) :-
    Implemented(Option&lt;Box&lt;Foo&gt;&gt;: Send).
</code></pre>
<p>As you can probably imagine, proving that <code>Option&lt;Box&lt;Foo&gt;&gt;: Send</code> is
going to wind up circularly requiring us to prove that <code>Foo: Send</code>
again. So this would be an example where we wind up in a cycle – but
that's ok, we <em>do</em> consider <code>Foo: Send</code> to hold, even though it
references itself.</p>
<p>In general, co-inductive traits are used in Rust trait solving when we
want to enumerate a fixed set of possibilities. In the case of auto
traits, we are enumerating the set of reachable types from a given
starting point (i.e., <code>Foo</code> can reach values of type
<code>Option&lt;Box&lt;Foo&gt;&gt;</code>, which implies it can reach values of type
<code>Box&lt;Foo&gt;</code>, and then of type <code>Foo</code>, and then the cycle is complete).</p>
<p>In addition to auto traits, <code>WellFormed</code> predicates are co-inductive.
These are used to achieve a similar &quot;enumerate all the cases&quot; pattern,
as described in the section on <a href="clauses/./lowering_rules.html#implied-bounds">implied bounds</a>.</p>
<h1><a class="header" href="#type-equality-and-unification" id="type-equality-and-unification">Type equality and unification</a></h1>
<p>This section covers how the trait system handles equality between
associated types. The full system consists of several moving parts,
which we will introduce one by one:</p>
<ul>
<li>Projection and the <code>Normalize</code> predicate</li>
<li>Placeholder associated type projections</li>
<li>The <code>ProjectionEq</code> predicate</li>
<li>Integration with unification</li>
</ul>
<h2><a class="header" href="#associated-type-projection-and-normalization" id="associated-type-projection-and-normalization">Associated type projection and normalization</a></h2>
<p>When a trait defines an associated type (e.g.,
<a href="https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html#associatedtype.Item">the <code>Item</code> type in the <code>IntoIterator</code> trait</a>), that
type can be referenced by the user using an <strong>associated type
projection</strong> like <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code>.</p>
<blockquote>
<p>Often, people will use the shorthand syntax <code>T::Item</code>. Presently, that
syntax is expanded during <a href="https://rustc-dev-guide.rust-lang.org/type-checking.html">&quot;type collection&quot;</a> into the
explicit form, though that is something we may want to change in the future.</p>
</blockquote>
<p><a name="normalize"></a></p>
<p>In some cases, associated type projections can be <strong>normalized</strong> –
that is, simplified – based on the types given in an impl. So, to
continue with our example, the impl of <code>IntoIterator</code> for <code>Option&lt;T&gt;</code>
declares (among other things) that <code>Item = T</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; IntoIterator for Option&lt;T&gt; {
  type Item = T;
  ...
}
</code></pre>
<p>This means we can normalize the projection <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code> to just <code>u32</code>.</p>
<p>In this case, the projection was a &quot;monomorphic&quot; one – that is, it
did not have any type parameters.  Monomorphic projections are special
because they can <strong>always</strong> be fully normalized.</p>
<p>Often, we can normalize other associated type projections as well. For
example, <code>&lt;Option&lt;?T&gt; as IntoIterator&gt;::Item</code>, where <code>?T</code> is an inference
variable, can be normalized to just <code>?T</code>.</p>
<p>In our logic, normalization is defined by a predicate
<code>Normalize</code>. The <code>Normalize</code> clauses arise only from
impls. For example, the <code>impl</code> of <code>IntoIterator</code> for <code>Option&lt;T&gt;</code> that
we saw above would be lowered to a program clause like so:</p>
<pre><code class="language-text">forall&lt;T&gt; {
    Normalize(&lt;Option&lt;T&gt; as IntoIterator&gt;::Item -&gt; T) :-
        Implemented(Option&lt;T&gt;: IntoIterator)
}
</code></pre>
<p>where in this case, the one <code>Implemented</code> condition is always true.</p>
<blockquote>
<p>Since we do not permit quantification over traits, this is really more like
a family of program clauses, one for each associated type.</p>
</blockquote>
<p>We could apply that rule to normalize either of the examples that
we've seen so far.</p>
<h2><a class="header" href="#placeholder-associated-types" id="placeholder-associated-types">Placeholder associated types</a></h2>
<p>Sometimes however we want to work with associated types that cannot be
normalized. For example, consider this function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: IntoIterator&gt;(...) { ... }
</code></pre>
<p>In this context, how would we normalize the type <code>T::Item</code>?</p>
<p>Without knowing what <code>T</code> is, we can't really do so. To represent this case,
we introduce a type called a <strong>placeholder associated type projection</strong>. This
is written like so: <code>(IntoIterator::Item)&lt;T&gt;</code>.</p>
<p>You may note that it looks a lot like a regular type (e.g., <code>Option&lt;T&gt;</code>),
except that the &quot;name&quot; of the type is <code>(IntoIterator::Item)</code>. This is not an
accident: placeholder associated type projections work just like ordinary
types like <code>Vec&lt;T&gt;</code> when it comes to unification. That is, they are only
considered equal if (a) they are both references to the same associated type,
like <code>IntoIterator::Item</code> and (b) their type arguments are equal.</p>
<p>Placeholder associated types are never written directly by the user.
They are used internally by the trait system only, as we will see
shortly.</p>
<p>In rustc, they correspond to the <code>TyKind::UnnormalizedProjectionTy</code> enum
variant, declared in <a href="https://github.com/rust-lang/rust/blob/master/src/librustc_middle/ty/sty.rs"><code>librustc_middle/ty/sty.rs</code></a>. In chalk, we use an
<code>ApplicationTy</code> with a name living in a special namespace dedicated to
placeholder associated types (see the <code>TypeName</code> enum declared in
<a href="https://github.com/rust-lang-nursery/chalk/blob/master/chalk-ir/src/lib.rs"><code>chalk-ir/src/lib.rs</code></a>).</p>
<h2><a class="header" href="#projection-equality" id="projection-equality">Projection equality</a></h2>
<p>So far we have seen two ways to answer the question of &quot;When can we
consider an associated type projection equal to another type?&quot;:</p>
<ul>
<li>the <code>Normalize</code> predicate could be used to transform projections when we
knew which impl applied;</li>
<li><strong>placeholder</strong> associated types can be used when we don't. This is also
known as <strong>lazy normalization</strong>.</li>
</ul>
<p>We now introduce the <code>ProjectionEq</code> predicate to bring those two cases
together. The <code>ProjectionEq</code> predicate looks like so:</p>
<pre><code class="language-text">ProjectionEq(&lt;T as IntoIterator&gt;::Item = U)
</code></pre>
<p>and we will see that it can be proven <em>either</em> via normalization or
via the placeholder type. As part of lowering an associated type declaration from
some trait, we create two program clauses for <code>ProjectionEq</code>:</p>
<pre><code class="language-text">forall&lt;T, U&gt; {
    ProjectionEq(&lt;T as IntoIterator&gt;::Item = U) :-
        Normalize(&lt;T as IntoIterator&gt;::Item -&gt; U)
}

forall&lt;T&gt; {
    ProjectionEq(&lt;T as IntoIterator&gt;::Item = (IntoIterator::Item)&lt;T&gt;)
}
</code></pre>
<p>These are the only two <code>ProjectionEq</code> program clauses we ever make for
any given associated item.</p>
<h2><a class="header" href="#integration-with-unification" id="integration-with-unification">Integration with unification</a></h2>
<p>Now we are ready to discuss how associated type equality integrates
with unification. As described in the
<a href="https://rustc-dev-guide.rust-lang.org/type-inference.html">type inference</a>
section, unification is basically a procedure with a signature like this:</p>
<pre><code class="language-text">Unify(A, B) = Result&lt;Subgoals, NoSolution&gt;
</code></pre>
<p>In other words, we try to unify two things A and B. That procedure
might just fail, in which case we get back <code>Err(NoSolution)</code>. This
would happen, for example, if we tried to unify <code>u32</code> and <code>i32</code>.</p>
<p>The key point is that, on success, unification can also give back to
us a set of subgoals that still remain to be proven.</p>
<p>Whenever unification encounters a non-placeholder associated type
projection P being equated with some other type T, it always succeeds,
but it produces a subgoal <code>ProjectionEq(P = T)</code> that is propagated
back up. Thus it falls to the ordinary workings of the trait system
to process that constraint.</p>
<blockquote>
<p>If we unify two projections P1 and P2, then unification produces a
variable X and asks us to prove that <code>ProjectionEq(P1 = X)</code> and
<code>ProjectionEq(P2 = X)</code>. (That used to be needed in an older system to
prevent cycles; I rather doubt it still is. -nmatsakis)</p>
</blockquote>
<h1><a class="header" href="#implied-bounds" id="implied-bounds">Implied Bounds</a></h1>
<p>Implied bounds remove the need to repeat where clauses written on
a type declaration or a trait declaration. For example, say we have the
following type declaration:</p>
<pre><code class="language-rust ignore">struct HashSet&lt;K: Hash&gt; {
    ...
}
</code></pre>
<p>then everywhere we use <code>HashSet&lt;K&gt;</code> as an &quot;input&quot; type, that is appearing in
the receiver type of an <code>impl</code> or in the arguments of a function, we don't
want to have to repeat the <code>where K: Hash</code> bound, as in:</p>
<pre><code class="language-rust ignore">// I don't want to have to repeat `where K: Hash` here.
impl&lt;K&gt; HashSet&lt;K&gt; {
    ...
}

// Same here.
fn loud_insert&lt;K&gt;(set: &amp;mut HashSet&lt;K&gt;, item: K) {
    println!(&quot;inserting!&quot;);
    set.insert(item);
}
</code></pre>
<p>Note that in the <code>loud_insert</code> example, <code>HashSet&lt;K&gt;</code> is not the type
of the <code>set</code> argument of <code>loud_insert</code>, it only <em>appears</em> in the
argument type <code>&amp;mut HashSet&lt;K&gt;</code>: we care about every type appearing
in the function's header (the header is the signature without the return type),
not only types of the function's arguments.</p>
<p>The rationale for applying implied bounds to input types is that, for example,
in order to call the <code>loud_insert</code> function above, the programmer must have
<em>produced</em> the type <code>HashSet&lt;K&gt;</code> already, hence the compiler already verified
that <code>HashSet&lt;K&gt;</code> was well-formed, i.e. that <code>K</code> effectively implemented
<code>Hash</code>, as in the following example:</p>
<pre><code class="language-rust ignore">fn main() {
    // I am producing a value of type `HashSet&lt;i32&gt;`.
    // If `i32` was not `Hash`, the compiler would report an error here.
    let set: HashSet&lt;i32&gt; = HashSet::new();
    loud_insert(&amp;mut set, 5);
}
</code></pre>
<p>Hence, we don't want to repeat where clauses for input types because that would
sort of duplicate the work of the programmer, having to verify that their types
are well-formed both when calling the function and when using them in the
arguments of their function. The same reasoning applies when using an <code>impl</code>.</p>
<p>Similarly, given the following trait declaration:</p>
<pre><code class="language-rust ignore">trait Copy where Self: Clone { // desugared version of `Copy: Clone`
    ...
}
</code></pre>
<p>then everywhere we bound over <code>SomeType: Copy</code>, we would like to be able to
use the fact that <code>SomeType: Clone</code> without having to write it explicitly,
as in:</p>
<pre><code class="language-rust ignore">fn loud_clone&lt;T: Clone&gt;(x: T) {
    println!(&quot;cloning!&quot;);
    x.clone();
}

fn fun_with_copy&lt;T: Copy&gt;(x: T) {
    println!(&quot;will clone a `Copy` type soon...&quot;);

    // I'm using `loud_clone&lt;T: Clone&gt;` with `T: Copy`, I know this
    // implies `T: Clone` so I don't want to have to write it explicitly.
    loud_clone(x);
}
</code></pre>
<p>The rationale for implied bounds for traits is that if a type implements
<code>Copy</code>, that is, if there exists an <code>impl Copy</code> for that type, there <em>ought</em>
to exist an <code>impl Clone</code> for that type, otherwise the compiler would have
reported an error in the first place. So again, if we were forced to repeat the
additional <code>where SomeType: Clone</code> everywhere whereas we already know that
<code>SomeType: Copy</code> hold, we would kind of duplicate the verification work.</p>
<p>Implied bounds are not yet completely enforced in rustc, at the moment it only
works for outlive requirements, super trait bounds, and bounds on associated
types. The full RFC can be found <a href="https://github.com/rust-lang/rfcs/blob/master/text/2089-implied-bounds.md">here</a>. We'll give here a brief view
of how implied bounds work and why we chose to implement it that way. The
complete set of lowering rules can be found in the corresponding
<a href="clauses/./lowering_rules.html">chapter</a>.</p>
<h2><a class="header" href="#implied-bounds-and-lowering-rules" id="implied-bounds-and-lowering-rules">Implied bounds and lowering rules</a></h2>
<p>Now we need to express implied bounds in terms of logical rules. We will start
with exposing a naive way to do it. Suppose that we have the following traits:</p>
<pre><code class="language-rust ignore">trait Foo {
    ...
}

trait Bar where Self: Foo { } {
    ...
}
</code></pre>
<p>So we would like to say that if a type implements <code>Bar</code>, then necessarily
it must also implement <code>Foo</code>. We might think that a clause like this would
work:</p>
<pre><code class="language-text">forall&lt;Type&gt; {
    Implemented(Type: Foo) :- Implemented(Type: Bar).
}
</code></pre>
<p>Now suppose that we just write this impl:</p>
<pre><code class="language-rust ignore">struct X;

impl Bar for X { }
</code></pre>
<p>Clearly this should not be allowed: indeed, we wrote a <code>Bar</code> impl for <code>X</code>, but
the <code>Bar</code> trait requires that we also implement <code>Foo</code> for <code>X</code>, which we never
did. In terms of what the compiler does, this would look like this:</p>
<pre><code class="language-rust ignore">struct X;

impl Bar for X {
    // We are in a `Bar` impl for the type `X`.
    // There is a `where Self: Foo` bound on the `Bar` trait declaration.
    // Hence I need to prove that `X` also implements `Foo` for that impl
    // to be legal.
}
</code></pre>
<p>So the compiler would try to prove <code>Implemented(X: Foo)</code>. Of course it will
not find any <code>impl Foo for X</code> since we did not write any. However, it
will see our implied bound clause:</p>
<pre><code class="language-text">forall&lt;Type&gt; {
    Implemented(Type: Foo) :- Implemented(Type: Bar).
}
</code></pre>
<p>so that it may be able to prove <code>Implemented(X: Foo)</code> if <code>Implemented(X: Bar)</code>
holds. And it turns out that <code>Implemented(X: Bar)</code> does hold since we wrote
a <code>Bar</code> impl for <code>X</code>! Hence the compiler will accept the <code>Bar</code> impl while it
should not.</p>
<h2><a class="header" href="#implied-bounds-coming-from-the-environment" id="implied-bounds-coming-from-the-environment">Implied bounds coming from the environment</a></h2>
<p>So the naive approach does not work. What we need to do is to somehow decouple
implied bounds from impls. Suppose we know that a type <code>SomeType&lt;...&gt;</code>
implements <code>Bar</code> and we want to deduce that <code>SomeType&lt;...&gt;</code> must also implement
<code>Foo</code>.</p>
<p>There are two possibilities: first, we have enough information about
<code>SomeType&lt;...&gt;</code> to see that there exists a <code>Bar</code> impl in the program which
covers <code>SomeType&lt;...&gt;</code>, for example a plain <code>impl&lt;...&gt; Bar for SomeType&lt;...&gt;</code>.
Then if the compiler has done its job correctly, there <em>must</em> exist a <code>Foo</code>
impl which covers <code>SomeType&lt;...&gt;</code>, e.g. another plain
<code>impl&lt;...&gt; Foo for SomeType&lt;...&gt;</code>. In that case then, we can just use this
impl and we do not need implied bounds at all.</p>
<p>Second possibility: we do not know enough about <code>SomeType&lt;...&gt;</code> in order to
find a <code>Bar</code> impl which covers it, for example if <code>SomeType&lt;...&gt;</code> is just
a type parameter in a function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Bar&gt;() {
    // We'd like to deduce `Implemented(T: Foo)`.
}
</code></pre>
<p>That is, the information that <code>T</code> implements <code>Bar</code> here comes from the
<em>environment</em>. The environment is the set of things that we assume to be true
when we type check some Rust declaration. In that case, what we assume is that
<code>T: Bar</code>. Then at that point, we might authorize ourselves to have some kind
of  &quot;local&quot; implied bound reasoning which would say
<code>Implemented(T: Foo) :- Implemented(T: Bar)</code>. This reasoning would
only be done within our <code>foo</code> function in order to avoid the earlier
problem where we had a global clause.</p>
<p>We can apply these local reasonings everywhere we can have an environment
-- i.e. when we can write where clauses -- that is, inside impls,
trait declarations, and type declarations.</p>
<h2><a class="header" href="#computing-implied-bounds-with-fromenv" id="computing-implied-bounds-with-fromenv">Computing implied bounds with <code>FromEnv</code></a></h2>
<p>The previous subsection showed that it was only useful to compute implied
bounds for facts coming from the environment.
We talked about &quot;local&quot; rules, but there are multiple possible strategies to
indeed implement the locality of implied bounds.</p>
<p>In rustc, the current strategy is to <em>elaborate</em> bounds: that is, each time
we have a fact in the environment, we recursively derive all the other things
that are implied by this fact until we reach a fixed point. For example, if
we have the following declarations:</p>
<pre><code class="language-rust ignore">trait A { }
trait B where Self: A { }
trait C where Self: B { }

fn foo&lt;T: C&gt;() {
    ...
}
</code></pre>
<p>then inside the <code>foo</code> function, we start with an environment containing only
<code>Implemented(T: C)</code>. Then because of implied bounds for the <code>C</code> trait, we
elaborate <code>Implemented(T: B)</code> and add it to our environment. Because of
implied bounds for the <code>B</code> trait, we elaborate <code>Implemented(T: A)</code>and add it
to our environment as well. We cannot elaborate anything else, so we conclude
that our final environment consists of <code>Implemented(T: A + B + C)</code>.</p>
<p>In the new-style trait system, we like to encode as many things as possible
with logical rules. So rather than &quot;elaborating&quot;, we have a set of <em>global</em>
program clauses defined like so:</p>
<pre><code class="language-text">forall&lt;T&gt; { Implemented(T: A) :- FromEnv(T: A). }

forall&lt;T&gt; { Implemented(T: B) :- FromEnv(T: B). }
forall&lt;T&gt; { FromEnv(T: A) :- FromEnv(T: B). }

forall&lt;T&gt; { Implemented(T: C) :- FromEnv(T: C). }
forall&lt;T&gt; { FromEnv(T: B) :- FromEnv(T: C). }
</code></pre>
<p>So these clauses are defined globally (that is, they are available from
everywhere in the program) but they cannot be used because the hypothesis
is always of the form <code>FromEnv(...)</code> which is a bit special. Indeed, as
indicated by the name, <code>FromEnv(...)</code> facts can <strong>only</strong> come from the
environment.
How it works is that in the <code>foo</code> function, instead of having an environment
containing <code>Implemented(T: C)</code>, we replace this environment with
<code>FromEnv(T: C)</code>. From here and thanks to the above clauses, we see that we
are able to reach any of <code>Implemented(T: A)</code>, <code>Implemented(T: B)</code> or
<code>Implemented(T: C)</code>, which is what we wanted.</p>
<h2><a class="header" href="#implied-bounds-and-well-formedness-checking" id="implied-bounds-and-well-formedness-checking">Implied bounds and well-formedness checking</a></h2>
<p>Implied bounds are tightly related with well-formedness checking.
Well-formedness checking is the process of checking that the impls the
programmer wrote are legal, what we referred to earlier as &quot;the compiler doing
its job correctly&quot;.</p>
<p>We already saw examples of illegal and legal impls:</p>
<pre><code class="language-rust ignore">trait Foo { }
trait Bar where Self: Foo { }

struct X;
struct Y;

impl Bar for X {
    // This impl is not legal: the `Bar` trait requires that we also
    // implement `Foo`, and we didn't.
}

impl Foo for Y {
    // This impl is legal: there is nothing to check as there are no where
    // clauses on the `Foo` trait.
}

impl Bar for Y {
    // This impl is legal: we have a `Foo` impl for `Y`.
}
</code></pre>
<p>We must define what &quot;legal&quot; and &quot;illegal&quot; mean. For this, we introduce another
predicate: <code>WellFormed(Type: Trait)</code>. We say that the trait reference
<code>Type: Trait</code> is well-formed if <code>Type</code> meets the bounds written on the
<code>Trait</code> declaration. For each impl we write, assuming that the where clauses
declared on the impl hold, the compiler tries to prove that the corresponding
trait reference is well-formed. The impl is legal if the compiler manages to do
so.</p>
<p>Coming to the definition of <code>WellFormed(Type: Trait)</code>, it would be tempting
to define it as:</p>
<pre><code class="language-rust ignore">trait Trait where WC1, WC2, ..., WCn {
    ...
}
</code></pre>
<pre><code class="language-text">forall&lt;Type&gt; {
    WellFormed(Type: Trait) :- WC1 &amp;&amp; WC2 &amp;&amp; .. &amp;&amp; WCn.
}
</code></pre>
<p>and indeed this was basically what was done in rustc until it was noticed that
this mixed badly with implied bounds. The key thing is that implied bounds
allows someone to derive all bounds implied by a fact in the environment, and
this <em>transitively</em> as we've seen with the <code>A + B + C</code> traits example.
However, the <code>WellFormed</code> predicate as defined above only checks that the
<em>direct</em> superbounds hold. That is, if we come back to our <code>A + B + C</code>
example:</p>
<pre><code class="language-rust ignore">trait A { }
// No where clauses, always well-formed.
// forall&lt;Type&gt; { WellFormed(Type: A). }

trait B where Self: A { }
// We only check the direct superbound `Self: A`.
// forall&lt;Type&gt; { WellFormed(Type: B) :- Implemented(Type: A). }

trait C where Self: B { }
// We only check the direct superbound `Self: B`. We do not check
// the `Self: A` implied bound  coming from the `Self: B` superbound.
// forall&lt;Type&gt; { WellFormed(Type: C) :- Implemented(Type: B). }
</code></pre>
<p>There is an asymmetry between the recursive power of implied bounds and
the shallow checking of <code>WellFormed</code>. It turns out that this asymmetry
can be <a href="https://github.com/rust-lang/rust/pull/43786">exploited</a>. Indeed, suppose that we define the following
traits:</p>
<pre><code class="language-rust ignore">trait Partial where Self: Copy { }
// WellFormed(Self: Partial) :- Implemented(Self: Copy).

trait Complete where Self: Partial { }
// WellFormed(Self: Complete) :- Implemented(Self: Partial).

impl&lt;T&gt; Partial for T where T: Complete { }

impl&lt;T&gt; Complete for T { }
</code></pre>
<p>For the <code>Partial</code> impl, what the compiler must prove is:</p>
<pre><code class="language-text">forall&lt;T&gt; {
    if (T: Complete) { // assume that the where clauses hold
        WellFormed(T: Partial) // show that the trait reference is well-formed
    }
}
</code></pre>
<p>Proving <code>WellFormed(T: Partial)</code> amounts to proving <code>Implemented(T: Copy)</code>.
However, we have <code>Implemented(T: Complete)</code> in our environment: thanks to
implied bounds, we can deduce <code>Implemented(T: Partial)</code>. Using implied bounds
one level deeper, we can deduce <code>Implemented(T: Copy)</code>. Finally, the <code>Partial</code>
impl is legal.</p>
<p>For the <code>Complete</code> impl, what the compiler must prove is:</p>
<pre><code class="language-text">forall&lt;T&gt; {
    WellFormed(T: Complete) // show that the trait reference is well-formed
}
</code></pre>
<p>Proving <code>WellFormed(T: Complete)</code> amounts to proving <code>Implemented(T: Partial)</code>.
We see that the <code>impl Partial for T</code> applies if we can prove
<code>Implemented(T: Complete)</code>, and it turns out we can prove this fact since our
<code>impl&lt;T&gt; Complete for T</code> is a blanket impl without any where clauses.</p>
<p>So both impls are legal and the compiler accepts the program. Moreover, thanks
to the <code>Complete</code> blanket impl, all types implement <code>Complete</code>. So we could
now use this impl like so:</p>
<pre><code class="language-rust ignore">fn eat&lt;T&gt;(x: T) { }

fn copy_everything&lt;T: Complete&gt;(x: T) {
    eat(x);
    eat(x);
}

fn main() {
    let not_copiable = vec![1, 2, 3, 4];
    copy_everything(not_copiable);
}
</code></pre>
<p>In this program, we use the fact that <code>Vec&lt;i32&gt;</code> implements <code>Complete</code>, as any
other type. Hence we can call <code>copy_everything</code> with an argument of type
<code>Vec&lt;i32&gt;</code>. Inside the <code>copy_everything</code> function, we have the
<code>Implemented(T: Complete)</code> bound in our environment. Thanks to implied bounds,
we can deduce <code>Implemented(T: Partial)</code>. Using implied bounds again, we deduce
<code>Implemented(T: Copy)</code> and we can indeed call the <code>eat</code> function which moves
the argument twice since its argument is <code>Copy</code>. Problem: the <code>T</code> type was
in fact <code>Vec&lt;i32&gt;</code> which is not copy at all, hence we will double-free the
underlying vec storage so we have a memory unsoundness in safe Rust.</p>
<p>Of course, disregarding the asymmetry between <code>WellFormed</code> and implied bounds,
this bug was possible only because we had some kind of self-referencing impls.
But self-referencing impls are very useful in practice and are not the real
culprits in this affair.</p>
<h2><a class="header" href="#co-inductiveness-of-wellformed" id="co-inductiveness-of-wellformed">Co-inductiveness of <code>WellFormed</code></a></h2>
<p>So the solution is to fix this asymmetry between <code>WellFormed</code> and implied
bounds. For that, we need for the <code>WellFormed</code> predicate to not only require
that the direct superbounds hold, but also all the bounds transitively implied
by the superbounds. What we can do is to have the following rules for the
<code>WellFormed</code> predicate:</p>
<pre><code class="language-rust ignore">trait A { }
// WellFormed(Self: A) :- Implemented(Self: A).

trait B where Self: A { }
// WellFormed(Self: B) :- Implemented(Self: B) &amp;&amp; WellFormed(Self: A).

trait C where Self: B { }
// WellFormed(Self: C) :- Implemented(Self: C) &amp;&amp; WellFormed(Self: B).
</code></pre>
<p>Notice that we are now also requiring <code>Implemented(Self: Trait)</code> for
<code>WellFormed(Self: Trait)</code> to be true: this is to simplify the process of
traversing all the implied bounds transitively. This does not change anything
when checking whether impls are legal, because since we assume
that the where clauses hold inside the impl, we know that the corresponding
trait reference do hold. Thanks to this setup, you can see that we indeed
require to prove the set of all bounds transitively implied by the where
clauses.</p>
<p>However there is still a catch. Suppose that we have the following trait
definition:</p>
<pre><code class="language-rust ignore">trait Foo where &lt;Self as Foo&gt;::Item: Foo {
    type Item;
}
</code></pre>
<p>so this definition is a bit more involved than the ones we've seen already
because it defines an associated item. However, the well-formedness rule
would not be more complicated:</p>
<pre><code class="language-text">WellFormed(Self: Foo) :-
    Implemented(Self: Foo) &amp;&amp;
    WellFormed(&lt;Self as Foo&gt;::Item: Foo).
</code></pre>
<p>Now we would like to write the following impl:</p>
<pre><code class="language-rust ignore">impl Foo for i32 {
    type Item = i32;
}
</code></pre>
<p>The <code>Foo</code> trait definition and the <code>impl Foo for i32</code> are perfectly valid
Rust: we're kind of recursively using our <code>Foo</code> impl in order to show that
the associated value indeed implements <code>Foo</code>, but that's ok. But if we
translate this to our well-formedness setting, the compiler proof process
inside the <code>Foo</code> impl is the following: it starts with proving that the
well-formedness goal <code>WellFormed(i32: Foo)</code> is true. In order to do that,
it must prove the following goals: <code>Implemented(i32: Foo)</code> and
<code>WellFormed(&lt;i32 as Foo&gt;::Item: Foo)</code>. <code>Implemented(i32: Foo)</code> holds because
there is our impl and there are no where clauses on it so it's always true.
However, because of the associated type value we used,
<code>WellFormed(&lt;i32 as Foo&gt;::Item: Foo)</code> simplifies to just
<code>WellFormed(i32: Foo)</code>. So in order to prove its original goal
<code>WellFormed(i32: Foo)</code>, the compiler needs to prove <code>WellFormed(i32: Foo)</code>:
this clearly is a cycle and cycles are usually rejected by the trait solver,
unless...  if the <code>WellFormed</code> predicate was made to be co-inductive.</p>
<p>A co-inductive predicate, as discussed in the chapter on
<a href="clauses/./goals_and_clauses.html#coinductive-goals">goals and clauses</a>, are predicates
for which the
trait solver accepts cycles. In our setting, this would be a valid thing to do:
indeed, the <code>WellFormed</code> predicate just serves as a way of enumerating all
the implied bounds. Hence, it's like a fixed point algorithm: it tries to grow
the set of implied bounds until there is nothing more to add. Here, a cycle
in the chain of <code>WellFormed</code> predicates just means that there is no more bounds
to add in that direction, so we can just accept this cycle and focus on other
directions. It's easy to prove that under these co-inductive semantics, we
are effectively visiting all the transitive implied bounds, and only these.</p>
<h2><a class="header" href="#implied-bounds-on-types" id="implied-bounds-on-types">Implied bounds on types</a></h2>
<p>We mainly talked about implied bounds for traits because this was the most
subtle regarding implementation. Implied bounds on types are simpler,
especially because if we assume that a type is well-formed, we don't use that
fact to deduce that other types are well-formed, we only use it to deduce
that e.g. some trait bounds hold.</p>
<p>For types, we just use rules like these ones:</p>
<pre><code class="language-rust ignore">struct Type&lt;...&gt; where WC1, ..., WCn {
    ...
}
</code></pre>
<pre><code class="language-text">forall&lt;...&gt; {
    WellFormed(Type&lt;...&gt;) :- WC1, ..., WCn.
}

forall&lt;...&gt; {
    FromEnv(WC1) :- FromEnv(Type&lt;...&gt;).
    ...
    FromEnv(WCn) :- FromEnv(Type&lt;...&gt;).
}
</code></pre>
<p>We can see that we have this asymmetry between well-formedness check,
which only verifies that the direct superbounds hold, and implied bounds which
gives access to all bounds transitively implied by the where clauses. In that
case this is ok because as we said, we don't use <code>FromEnv(Type&lt;...&gt;)</code> to deduce
other <code>FromEnv(OtherType&lt;...&gt;)</code> things, nor do we use <code>FromEnv(Type: Trait)</code> to
deduce <code>FromEnv(OtherType&lt;...&gt;)</code> things. So in that sense type definitions are
&quot;less recursive&quot; than traits, and we saw in a previous subsection that
it was the combination of asymmetry and recursive trait / impls that led to
unsoundness. As such, the <code>WellFormed(Type&lt;...&gt;)</code> predicate does not need
to be co-inductive.</p>
<p>This asymmetry optimization is useful because in a real Rust program, we have
to check the well-formedness of types very often (e.g. for each type which
appears in the body of a function).</p>
<h1><a class="header" href="#lowering-rules" id="lowering-rules">Lowering rules</a></h1>
<p>This section gives the complete lowering rules for Rust traits into
<a href="clauses/./goals_and_clauses.html">program clauses</a>. It is a kind of reference. These rules
reference the <a href="clauses/./goals_and_clauses.html#domain-goals">domain goals</a> defined in an earlier section.</p>
<h2><a class="header" href="#notation" id="notation">Notation</a></h2>
<p>The nonterminal <code>Pi</code> is used to mean some generic <em>parameter</em>, either a
named lifetime like <code>'a</code> or a type parameter like <code>A</code>.</p>
<p>The nonterminal <code>Ai</code> is used to mean some generic <em>argument</em>, which
might be a lifetime like <code>'a</code> or a type like <code>Vec&lt;A&gt;</code>.</p>
<p>When defining the lowering rules, we will give goals and clauses in
the <a href="clauses/./goals_and_clauses.html">notation given in this section</a>.
We sometimes insert &quot;macros&quot; like <code>LowerWhereClause!</code> into these
definitions; these macros reference other sections within this chapter.</p>
<h2><a class="header" href="#rule-names-and-cross-references" id="rule-names-and-cross-references">Rule names and cross-references</a></h2>
<p>Each of these lowering rules is given a name, documented with a
comment like so:</p>
<pre><code>// Rule Foo-Bar-Baz
</code></pre>
<p>The reference implementation of these rules is to be found in
<a href="https://github.com/rust-lang/chalk/blob/master/chalk-solve/src/clauses.rs"><code>chalk/chalk-solve/src/clauses.rs</code></a>. They are also ported in
rustc in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_traits"><code>librustc_traits</code></a> crate.</p>
<h2><a class="header" href="#lowering-where-clauses" id="lowering-where-clauses">Lowering where clauses</a></h2>
<p>When used in a goal position, where clauses can be mapped directly to
the <code>Holds</code> variant of <a href="clauses/./goals_and_clauses.html#domain-goals">domain goals</a>, as follows:</p>
<ul>
<li><code>A0: Foo&lt;A1..An&gt;</code> maps to <code>Implemented(A0: Foo&lt;A1..An&gt;)</code></li>
<li><code>T: 'r</code> maps to <code>Outlives(T, 'r)</code></li>
<li><code>'a: 'b</code> maps to <code>Outlives('a, 'b)</code></li>
<li><code>A0: Foo&lt;A1..An, Item = T&gt;</code> is a bit special and expands to two distinct
goals, namely <code>Implemented(A0: Foo&lt;A1..An&gt;)</code> and
<code>ProjectionEq(&lt;A0 as Foo&lt;A1..An&gt;&gt;::Item = T)</code></li>
</ul>
<p>In the rules below, we will use <code>WC</code> to indicate where clauses that
appear in Rust syntax; we will then use the same <code>WC</code> to indicate
where those where clauses appear as goals in the program clauses that
we are producing. In that case, the mapping above is used to convert
from the Rust syntax into goals.</p>
<h3><a class="header" href="#transforming-the-lowered-where-clauses" id="transforming-the-lowered-where-clauses">Transforming the lowered where clauses</a></h3>
<p>In addition, in the rules below, we sometimes do some transformations
on the lowered where clauses, as defined here:</p>
<ul>
<li><code>FromEnv(WC)</code> – this indicates that:
<ul>
<li><code>Implemented(TraitRef)</code> becomes <code>FromEnv(TraitRef)</code></li>
<li>other where-clauses are left intact</li>
</ul>
</li>
<li><code>WellFormed(WC)</code> – this indicates that:
<ul>
<li><code>Implemented(TraitRef)</code> becomes <code>WellFormed(TraitRef)</code></li>
<li>other where-clauses are left intact</li>
</ul>
</li>
</ul>
<p><em>TODO</em>: I suspect that we want to alter the outlives relations too,
but Chalk isn't modeling those right now.</p>
<h2><a class="header" href="#lowering-traits" id="lowering-traits">Lowering traits</a></h2>
<p>Given a trait definition</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1..Pn&gt; // P0 == Self
where WC
{
    // trait items
}
</code></pre>
<p>we will produce a number of declarations. This section is focused on
the program clauses for the trait header (i.e., the stuff outside the
<code>{}</code>); the <a href="clauses/lowering_rules.html#trait-items">section on trait items</a> covers the stuff
inside the <code>{}</code>.</p>
<h3><a class="header" href="#trait-header" id="trait-header">Trait header</a></h3>
<p>From the trait itself we mostly make &quot;meta&quot; rules that setup the
relationships between different kinds of domain goals.  The first such
rule from the trait header creates the mapping between the <code>FromEnv</code>
and <code>Implemented</code> predicates:</p>
<pre><code class="language-text">// Rule Implemented-From-Env
forall&lt;Self, P1..Pn&gt; {
  Implemented(Self: Trait&lt;P1..Pn&gt;) :- FromEnv(Self: Trait&lt;P1..Pn&gt;)
}
</code></pre>
<p><a name="implied-bounds"></a></p>
<h4><a class="header" href="#implied-bounds-1" id="implied-bounds-1">Implied bounds</a></h4>
<p>The next few clauses have to do with implied bounds (see also
<a href="https://rust-lang.github.io/rfcs/2089-implied-bounds.html">RFC 2089</a> and the <a href="clauses/./implied_bounds.html">implied bounds</a> chapter for a more in depth
cover). For each trait, we produce two clauses:</p>
<pre><code class="language-text">// Rule Implied-Bound-From-Trait
//
// For each where clause WC:
forall&lt;Self, P1..Pn&gt; {
  FromEnv(WC) :- FromEnv(Self: Trait&lt;P1..Pn&gt;)
}
</code></pre>
<p>This clause says that if we are assuming that the trait holds, then we can also
assume that its where-clauses hold. It's perhaps useful to see an example:</p>
<pre><code class="language-rust ignore">trait Eq: PartialEq { ... }
</code></pre>
<p>In this case, the <code>PartialEq</code> supertrait is equivalent to a <code>where Self: PartialEq</code> where clause, in our simplified model. The program
clause above therefore states that if we can prove <code>FromEnv(T: Eq)</code> –
e.g., if we are in some function with <code>T: Eq</code> in its where clauses –
then we also know that <code>FromEnv(T: PartialEq)</code>. Thus the set of things
that follow from the environment are not only the <strong>direct where
clauses</strong> but also things that follow from them.</p>
<p>The next rule is related; it defines what it means for a trait reference
to be <strong>well-formed</strong>:</p>
<pre><code class="language-text">// Rule WellFormed-TraitRef
forall&lt;Self, P1..Pn&gt; {
  WellFormed(Self: Trait&lt;P1..Pn&gt;) :- Implemented(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WellFormed(WC)
}
</code></pre>
<p>This <code>WellFormed</code> rule states that <code>T: Trait</code> is well-formed if (a)
<code>T: Trait</code> is implemented and (b) all the where-clauses declared on
<code>Trait</code> are well-formed (and hence they are implemented). Remember
that the <code>WellFormed</code> predicate is
<a href="clauses/./goals_and_clauses.html#coinductive">coinductive</a>; in this
case, it is serving as a kind of &quot;carrier&quot; that allows us to enumerate
all the where clauses that are transitively implied by <code>T: Trait</code>.</p>
<p>An example:</p>
<pre><code class="language-rust ignore">trait Foo: A + Bar { }
trait Bar: B + Foo { }
trait A { }
trait B { }
</code></pre>
<p>Here, the transitive set of implications for <code>T: Foo</code> are <code>T: A</code>, <code>T: Bar</code>, and
<code>T: B</code>.  And indeed if we were to try to prove <code>WellFormed(T: Foo)</code>, we would
have to prove each one of those:</p>
<ul>
<li><code>WellFormed(T: Foo)</code>
<ul>
<li><code>Implemented(T: Foo)</code></li>
<li><code>WellFormed(T: A)</code>
<ul>
<li><code>Implemented(T: A)</code></li>
</ul>
</li>
<li><code>WellFormed(T: Bar)</code>
<ul>
<li><code>Implemented(T: Bar)</code></li>
<li><code>WellFormed(T: B)</code>
<ul>
<li><code>Implemented(T: Bar)</code></li>
</ul>
</li>
<li><code>WellFormed(T: Foo)</code> -- cycle, true coinductively</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This <code>WellFormed</code> predicate is only used when proving that impls are
well-formed – basically, for each impl of some trait ref <code>TraitRef</code>,
we must show that <code>WellFormed(TraitRef)</code>. This in turn justifies the
implied bounds rules that allow us to extend the set of <code>FromEnv</code>
items.</p>
<h2><a class="header" href="#lowering-type-definitions" id="lowering-type-definitions">Lowering type definitions</a></h2>
<p>We also want to have some rules which define when a type is well-formed.
For example, given this type:</p>
<pre><code class="language-rust ignore">struct Set&lt;K&gt; where K: Hash { ... }
</code></pre>
<p>then <code>Set&lt;i32&gt;</code> is well-formed because <code>i32</code> implements <code>Hash</code>, but
<code>Set&lt;NotHash&gt;</code> would not be well-formed. Basically, a type is well-formed
if its parameters verify the where clauses written on the type definition.</p>
<p>Hence, for every type definition:</p>
<pre><code class="language-rust ignore">struct Type&lt;P1..Pn&gt; where WC { ... }
</code></pre>
<p>we produce the following rule:</p>
<pre><code class="language-text">// Rule WellFormed-Type
forall&lt;P1..Pn&gt; {
  WellFormed(Type&lt;P1..Pn&gt;) :- WC
}
</code></pre>
<p>Note that we use <code>struct</code> for defining a type, but this should be understood
as a general type definition (it could be e.g. a generic <code>enum</code>).</p>
<p>Conversely, we define rules which say that if we assume that a type is
well-formed, we can also assume that its where clauses hold. That is,
we produce the following family of rules:</p>
<pre><code class="language-text">// Rule Implied-Bound-From-Type
//
// For each where clause `WC`
forall&lt;P1..Pn&gt; {
  FromEnv(WC) :- FromEnv(Type&lt;P1..Pn&gt;)
}
</code></pre>
<p>As for the implied bounds RFC, functions will <em>assume</em> that their arguments
are well-formed. For example, suppose we have the following bit of code:</p>
<pre><code class="language-rust ignore">trait Hash: Eq { }
struct Set&lt;K: Hash&gt; { ... }

fn foo&lt;K&gt;(collection: Set&lt;K&gt;, x: K, y: K) {
    // `x` and `y` can be equalized even if we did not explicitly write
    // `where K: Eq`
    if x == y {
        ...
    }
}
</code></pre>
<p>In the <code>foo</code> function, we assume that <code>Set&lt;K&gt;</code> is well-formed, i.e. we have
<code>FromEnv(Set&lt;K&gt;)</code> in our environment. Because of the previous rule, we get
<code>FromEnv(K: Hash)</code> without needing an explicit where clause. And because
of the <code>Hash</code> trait definition, there also exists a rule which says:</p>
<pre><code class="language-text">forall&lt;K&gt; {
  FromEnv(K: Eq) :- FromEnv(K: Hash)
}
</code></pre>
<p>which means that we finally get <code>FromEnv(K: Eq)</code> and then can compare <code>x</code>
and <code>y</code> without needing an explicit where clause.</p>
<p><a name="trait-items"></a></p>
<h2><a class="header" href="#lowering-trait-items" id="lowering-trait-items">Lowering trait items</a></h2>
<h3><a class="header" href="#associated-type-declarations" id="associated-type-declarations">Associated type declarations</a></h3>
<p>Given a trait that declares a (possibly generic) associated type:</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1..Pn&gt; // P0 == Self
where WC
{
    type AssocType&lt;Pn+1..Pm&gt;: Bounds where WC1;
}
</code></pre>
<p>We will produce a number of program clauses. The first two define
the rules by which <code>ProjectionEq</code> can succeed; these two clauses are discussed
in detail in the <a href="clauses/./type_equality.html">section on associated types</a>,
but reproduced here for reference:</p>
<pre><code class="language-text">// Rule ProjectionEq-Normalize
//
// ProjectionEq can succeed by normalizing:
forall&lt;Self, P1..Pn, Pn+1..Pm, U&gt; {
  ProjectionEq(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; = U) :-
      Normalize(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; -&gt; U)
}
</code></pre>
<pre><code class="language-text">// Rule ProjectionEq-Placeholder
//
// ProjectionEq can succeed through the placeholder associated type,
// see &quot;associated type&quot; chapter for more:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
  ProjectionEq(
    &lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; =
    (Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;
  )
}
</code></pre>
<p>The next rule covers implied bounds for the projection. In particular,
the <code>Bounds</code> declared on the associated type must have been proven to hold
to show that the impl is well-formed, and hence we can rely on them
elsewhere.</p>
<pre><code class="language-text">// Rule Implied-Bound-From-AssocTy
//
// For each `Bound` in `Bounds`:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt;&gt;: Bound) :-
      FromEnv(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WC1
}
</code></pre>
<p>Next, we define the requirements for an instantiation of our associated
type to be well-formed...</p>
<pre><code class="language-text">// Rule WellFormed-AssocTy
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    WellFormed((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;) :-
      Implemented(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WC1
}
</code></pre>
<p>...along with the reverse implications, when we can assume that it is
well-formed.</p>
<pre><code class="language-text">// Rule Implied-WC-From-AssocTy
//
// For each where clause WC1:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(WC1) :- FromEnv((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;)
}
</code></pre>
<pre><code class="language-text">// Rule Implied-Trait-From-AssocTy
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(Self: Trait&lt;P1..Pn&gt;) :-
      FromEnv((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;)
}
</code></pre>
<h3><a class="header" href="#lowering-function-and-constant-declarations" id="lowering-function-and-constant-declarations">Lowering function and constant declarations</a></h3>
<p>Chalk didn't model functions and constants, but I would eventually like to
treat them exactly like normalization. See <a href="clauses/lowering_rules.html#constant-vals">the section on function/constant
values below</a> for more details.</p>
<h2><a class="header" href="#lowering-impls" id="lowering-impls">Lowering impls</a></h2>
<p>Given an impl of a trait:</p>
<pre><code class="language-rust ignore">impl&lt;P0..Pn&gt; Trait&lt;A1..An&gt; for A0
where WC
{
    // zero or more impl items
}
</code></pre>
<p>Let <code>TraitRef</code> be the trait reference <code>A0: Trait&lt;A1..An&gt;</code>. Then we
will create the following rules:</p>
<pre><code class="language-text">// Rule Implemented-From-Impl
forall&lt;P0..Pn&gt; {
  Implemented(TraitRef) :- WC
}
</code></pre>
<p>In addition, we will lower all of the <em>impl items</em>.</p>
<h2><a class="header" href="#lowering-impl-items" id="lowering-impl-items">Lowering impl items</a></h2>
<h3><a class="header" href="#associated-type-values" id="associated-type-values">Associated type values</a></h3>
<p>Given an impl that contains:</p>
<pre><code class="language-rust ignore">impl&lt;P0..Pn&gt; Trait&lt;P1..Pn&gt; for P0
where WC_impl
{
    type AssocType&lt;Pn+1..Pm&gt; = T;
}
</code></pre>
<p>and our where clause <code>WC1</code> on the trait associated type from above, we
produce the following rule:</p>
<pre><code class="language-text">// Rule Normalize-From-Impl
forall&lt;P0..Pm&gt; {
  forall&lt;Pn+1..Pm&gt; {
    Normalize(&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; -&gt; T) :-
      Implemented(P0 as Trait) &amp;&amp; WC1
  }
}
</code></pre>
<p>Note that <code>WC_impl</code> and <code>WC1</code> both encode where-clauses that the impl can
rely on. (<code>WC_impl</code> is not used here, because it is implied by
<code>Implemented(P0 as Trait)</code>.)</p>
<p><a name="constant-vals"></a></p>
<h3><a class="header" href="#function-and-constant-values" id="function-and-constant-values">Function and constant values</a></h3>
<p>Chalk didn't model functions and constants, but I would eventually
like to treat them exactly like normalization. This presumably
involves adding a new kind of parameter (constant), and then having a
<code>NormalizeValue</code> domain goal. This is <em>to be written</em> because the
details are a bit up in the air.</p>
<h1><a class="header" href="#well-known-traits" id="well-known-traits">Well known traits</a></h1>
<p>For most traits, the question of whether some type T implements the trait is determined by 
looking solely at the impls that exist for the trait. But there are some well-known traits 
where we have &quot;built-in&quot; impls that are never expressly written in the compiler, they are 
built-in to the language itself. In some cases, these impls also encode complex conditions
that an ordinary impl cannot express. To address this, chalk has a notion of a <code>WellKnownTrait</code> 
-- basically, a trait which is inherent to the language and where we will generate custom logic.</p>
<p>As an example, consider the logic for <code>Sized</code> in regards to structs: A struct can have
at most one <code>!Sized</code> field, and it must be the last. And the last field isn't <code>Sized</code>, 
then neither is the struct itself. </p>
<p>Chalk has two main places that deal with well known trait logic:</p>
<ol>
<li><a href="https://github.com/rust-lang/chalk/blob/master/chalk-solve/src/clauses/builtin_traits.rs"><code>chalk-solve\clauses\builtin_traits</code></a>, which generates built-in implementations
for well-known traits.</li>
<li><a href="clauses/wf.html">well-formedness</a> checks, some of which need to know about well known traits.</li>
</ol>
<h1><a class="header" href="#auto-traits" id="auto-traits">Auto traits</a></h1>
<p>Auto traits, while not exactly well known traits, do also have special logic. 
The idea is that the type implements an auto trait if all data owned by that type implements it, 
with an ability to specifically opt-out or opt-in. Additionally, auto traits are <a href="clauses/../engine/logic/coinduction.html#coinduction-and-refinement-strands">coinductive</a>. 
Some common examples of auto traits are <code>Send</code> and <code>Sync</code>.</p>
<h1><a class="header" href="#current-state" id="current-state">Current state</a></h1>
<table><thead><tr><th>Type</th><th>Copy</th><th>Clone</th><th>Sized</th><th>Unsize</th><th>Drop</th><th>FnOnce/FnMut/Fn</th><th>Unpin</th><th>Generator</th><th>auto traits</th></tr></thead><tbody>
<tr><td>tuple types</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>structs</td><td>⚬</td><td>⚬</td><td>✅</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>scalar types</td><td>📚</td><td>📚</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>str</td><td>📚</td><td>📚</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>never type</td><td>📚</td><td>📚</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>trait objects</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td></tr>
<tr><td>functions defs</td><td>✅</td><td>✅</td><td>✅</td><td>⚬</td><td>⚬</td><td>❌</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>functions ptrs</td><td>✅</td><td>✅</td><td>✅</td><td>⚬</td><td>⚬</td><td>✅</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>raw ptrs</td><td>📚</td><td>📚</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>immutable refs</td><td>📚</td><td>📚</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>mutable refs</td><td>⚬</td><td>⚬</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>slices</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>arrays</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>closures❌</td><td>❌</td><td>❌</td><td>❌</td><td>⚬</td><td>⚬</td><td>❌</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>generators❌</td><td>⚬</td><td>⚬</td><td>❌</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>gen. witness❌</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>-----------</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>well-formedness</td><td>✅</td><td>⚬</td><td>✅</td><td>⚬</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td></tr>
</tbody></table>
<p>legend:<br />
⚬ - not applicable<br />
✅ - implemented<br />
📚 - implementation provided in libcore<br />
❌ - not implemented</p>
<p>❌ after a type name means that type is not yet in chalk</p>
<h1><a class="header" href="#well-formedness-checking" id="well-formedness-checking">Well-formedness checking</a></h1>
<p>WF checking has the job of checking that the various declarations in a Rust
program are well-formed. This is the basis for implied bounds, and partly for
that reason, this checking can be surprisingly subtle! For example, we
have to be sure that each impl proves the WF conditions declared on
the trait.</p>
<p>For each declaration in a Rust program, we will generate a logical goal and try
to prove it using the lowered rules we described in the
<a href="clauses/./lowering_rules.html">lowering rules</a> chapter. If we are able to prove it, we
say that the construct is well-formed. If not, we report an error to the user.</p>
<p>Well-formedness checking happens in the <a href="https://github.com/rust-lang/chalk/blob/master/chalk-solve/src/wf.rs"><code>chalk/chalk-solve/src/wf.rs</code></a>
module in chalk. After you have read this chapter, you may find useful to see
an extended set of examples in the <a href="https://github.com/rust-lang/chalk/blob/master/tests/test/wf_lowering.rs"><code>chalk/tests/test/wf_lowering.rs</code></a> submodule.</p>
<p>The new-style WF checking has not been implemented in rustc yet.</p>
<p>We give here a complete reference of the generated goals for each Rust
declaration.</p>
<p>In addition to the notations introduced in the chapter about
lowering rules, we'll introduce another notation: when checking WF of a
declaration, we'll often have to prove that all types that appear are
well-formed, except type parameters that we always assume to be WF. Hence,
we'll use the following notation: for a type <code>SomeType&lt;...&gt;</code>, we define
<code>InputTypes(SomeType&lt;...&gt;)</code> to be the set of all non-parameter types appearing
in <code>SomeType&lt;...&gt;</code>, including <code>SomeType&lt;...&gt;</code> itself.</p>
<p>Examples:</p>
<ul>
<li><code>InputTypes((u32, f32)) = [u32, f32, (u32, f32)]</code></li>
<li><code>InputTypes(Box&lt;T&gt;) = [Box&lt;T&gt;]</code> (assuming that <code>T</code> is a type parameter)</li>
<li><code>InputTypes(Box&lt;Box&lt;T&gt;&gt;) = [Box&lt;T&gt;, Box&lt;Box&lt;T&gt;&gt;]</code></li>
</ul>
<p>We also extend the <code>InputTypes</code> notation to where clauses in the natural way.
So, for example <code>InputTypes(A0: Trait&lt;A1,...,An&gt;)</code> is the union of
<code>InputTypes(A0)</code>, <code>InputTypes(A1)</code>, ..., <code>InputTypes(An)</code>.</p>
<h1><a class="header" href="#type-definitions" id="type-definitions">Type definitions</a></h1>
<p>Given a general type definition:</p>
<pre><code class="language-rust ignore">struct Type&lt;P...&gt; where WC_type {
    field1: A1,
    ...
    fieldn: An,
}
</code></pre>
<p>we generate the following goal, which represents its well-formedness condition:</p>
<pre><code class="language-text">forall&lt;P...&gt; {
    if (FromEnv(WC_type)) {
        WellFormed(InputTypes(WC_type)) &amp;&amp;
            WellFormed(InputTypes(A1)) &amp;&amp;
            ...
            WellFormed(InputTypes(An))
    }
}
</code></pre>
<p>which in English states: assuming that the where clauses defined on the type
hold, prove that every type appearing in the type definition is well-formed.</p>
<p>Some examples:</p>
<pre><code class="language-rust ignore">struct OnlyClone&lt;T&gt; where T: Clone {
    clonable: T,
}
// The only types appearing are type parameters: we have nothing to check,
// the type definition is well-formed.
</code></pre>
<pre><code class="language-rust ignore">struct Foo&lt;T&gt; where T: Clone {
    foo: OnlyClone&lt;T&gt;,
}
// The only non-parameter type which appears in this definition is
// `OnlyClone&lt;T&gt;`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Clone)) {
//          WellFormed(OnlyClone&lt;T&gt;)
//     }
// }
// ```
// which is provable.
</code></pre>
<pre><code class="language-rust ignore">struct Bar&lt;T&gt; where &lt;T as Iterator&gt;::Item: Debug {
    bar: i32,
}
// The only non-parameter types which appear in this definition are
// `&lt;T as Iterator&gt;::Item` and `i32`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(&lt;T as Iterator&gt;::Item: Debug)) {
//          WellFormed(&lt;T as Iterator&gt;::Item) &amp;&amp;
//               WellFormed(i32)
//     }
// }
// ```
// which is not provable since `WellFormed(&lt;T as Iterator&gt;::Item)` requires
// proving `Implemented(T: Iterator)`, and we are unable to prove that for an
// unknown `T`.
//
// Hence, this type definition is considered illegal. An additional
// `where T: Iterator` would make it legal.
</code></pre>
<h1><a class="header" href="#trait-definitions" id="trait-definitions">Trait definitions</a></h1>
<p>Given a general trait definition:</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1...&gt; where WC_trait {
    type Assoc&lt;P2...&gt;: Bounds_assoc where WC_assoc;
}
</code></pre>
<p>we generate the following goal:</p>
<pre><code class="language-text">forall&lt;P1...&gt; {
    if (FromEnv(WC_trait)) {
        WellFormed(InputTypes(WC_trait)) &amp;&amp;

            forall&lt;P2...&gt; {
                if (FromEnv(WC_assoc)) {
                    WellFormed(InputTypes(Bounds_assoc)) &amp;&amp;
                        WellFormed(InputTypes(WC_assoc))
                }
            }
    }
}
</code></pre>
<p>There is not much to verify in a trait definition. We just want
to prove that the types appearing in the trait definition are well-formed,
under the assumption that the different where clauses hold.</p>
<p>Some examples:</p>
<pre><code class="language-rust ignore">trait Foo&lt;T&gt; where T: Iterator, &lt;T as Iterator&gt;::Item: Debug {
    ...
}
// The only non-parameter type which appears in this definition is
// `&lt;T as Iterator&gt;::Item`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Iterator), FromEnv(&lt;T as Iterator&gt;::Item: Debug)) {
//         WellFormed(&lt;T as Iterator&gt;::Item)
//     }
// }
// ```
// which is provable thanks to the `FromEnv(T: Iterator)` assumption.
</code></pre>
<pre><code class="language-rust ignore">trait Bar {
    type Assoc&lt;T&gt;: From&lt;&lt;T as Iterator&gt;::Item&gt;;
}
// The only non-parameter type which appears in this definition is
// `&lt;T as Iterator&gt;::Item`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     WellFormed(&lt;T as Iterator&gt;::Item)
// }
// ```
// which is not provable, hence the trait definition is considered illegal.
</code></pre>
<pre><code class="language-rust ignore">trait Baz {
    type Assoc&lt;T&gt;: From&lt;&lt;T as Iterator&gt;::Item&gt; where T: Iterator;
}
// The generated goal is now:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Iterator)) {
//         WellFormed(&lt;T as Iterator&gt;::Item)
//     }
// }
// ```
// which is now provable.
</code></pre>
<h1><a class="header" href="#impls" id="impls">Impls</a></h1>
<p>Now we give ourselves a general impl for the trait defined above:</p>
<pre><code class="language-rust ignore">impl&lt;P1...&gt; Trait&lt;A1...&gt; for SomeType&lt;A2...&gt; where WC_impl {
    type Assoc&lt;P2...&gt; = SomeValue&lt;A3...&gt; where WC_assoc;
}
</code></pre>
<p>Note that here, <code>WC_assoc</code> are the same where clauses as those defined on the
associated type definition in the trait declaration, <em>except</em> that type
parameters from the trait are substituted with values provided by the impl
(see example below). You cannot add new where clauses. You may omit to write
the where clauses if you want to emphasize the fact that you are actually not
relying on them.</p>
<p>Some examples to illustrate that:</p>
<pre><code class="language-rust ignore">trait Foo&lt;T&gt; {
    type Assoc where T: Clone;
}

struct OnlyClone&lt;T: Clone&gt; { ... }

impl&lt;U&gt; Foo&lt;Option&lt;U&gt;&gt; for () {
    // We substitute type parameters from the trait by the ones provided
    // by the impl, that is instead of having a `T: Clone` where clause,
    // we have an `Option&lt;U&gt;: Clone` one.
    type Assoc = OnlyClone&lt;Option&lt;U&gt;&gt; where Option&lt;U&gt;: Clone;
}

impl&lt;T&gt; Foo&lt;T&gt; for i32 {
    // I'm not using the `T: Clone` where clause from the trait, so I can
    // omit it.
    type Assoc = u32;
}

impl&lt;T&gt; Foo&lt;T&gt; for f32 {
    type Assoc = OnlyClone&lt;Option&lt;T&gt;&gt; where Option&lt;T&gt;: Clone;
    //                                ^^^^^^^^^^^^^^^^^^^^^^
    //                                this where clause does not exist
    //                                on the original trait decl: illegal
}
</code></pre>
<blockquote>
<p>So in Rust, where clauses on associated types work <em>exactly</em> like where
clauses on trait methods: in an impl, we must substitute the parameters from
the traits with values provided by the impl, we may omit them if we don't
need them, but we cannot add new where clauses.</p>
</blockquote>
<p>Now let's see the generated goal for this general impl:</p>
<pre><code class="language-text">forall&lt;P1...&gt; {
    // Well-formedness of types appearing in the impl
    if (FromEnv(WC_impl), FromEnv(InputTypes(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;))) {
        WellFormed(InputTypes(WC_impl)) &amp;&amp;

            forall&lt;P2...&gt; {
                if (FromEnv(WC_assoc)) {
                        WellFormed(InputTypes(SomeValue&lt;A3...&gt;))
                }
            }
    }

    // Implied bounds checking
    if (FromEnv(WC_impl), FromEnv(InputTypes(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;))) {
        WellFormed(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;) &amp;&amp;

            forall&lt;P2...&gt; {
                if (FromEnv(WC_assoc)) {
                    WellFormed(SomeValue&lt;A3...&gt;: Bounds_assoc)
                }
            }
    }
}
</code></pre>
<p>Here is the most complex goal. As always, first, assuming that
the various where clauses hold, we prove that every type appearing in the impl
is well-formed, <em><strong>except</strong></em> types appearing in the impl header
<code>SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;</code>. Instead, we <em>assume</em> that those types are
well-formed
(hence the <code>if (FromEnv(InputTypes(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;)))</code>
conditions). This is
part of the implied bounds proposal, so that we can rely on the bounds
written on the definition of e.g. the <code>SomeType&lt;A2...&gt;</code> type (and that we don't
need to repeat those bounds).</p>
<blockquote>
<p>Note that we don't need to check well-formedness of types appearing in
<code>WC_assoc</code> because we already did that in the trait decl (they are just
repeated with some substitutions of values which we already assume to be
well-formed)</p>
</blockquote>
<p>Next, still assuming that the where clauses on the impl <code>WC_impl</code> hold and that
the input types of <code>SomeType&lt;A2...&gt;</code> are well-formed, we prove that
<code>WellFormed(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;)</code> hold. That is, we want to prove
that <code>SomeType&lt;A2...&gt;</code> verify all the where clauses that might transitively
be required by the <code>Trait</code> definition (see
<a href="clauses/./implied_bounds.html#co-inductiveness-of-wellformed">this subsection</a>).</p>
<p>Lastly, assuming in addition that the where clauses on the associated type
<code>WC_assoc</code> hold,
we prove that <code>WellFormed(SomeValue&lt;A3...&gt;: Bounds_assoc)</code> hold. Again, we are
not only proving <code>Implemented(SomeValue&lt;A3...&gt;: Bounds_assoc)</code>, but also
all the facts that might transitively come from <code>Bounds_assoc</code>. We must do this
because we allow the use of implied bounds on associated types: if we have
<code>FromEnv(SomeType: Trait)</code> in our environment, the lowering rules
chapter indicates that we are able to deduce
<code>FromEnv(&lt;SomeType as Trait&gt;::Assoc: Bounds_assoc)</code> without knowing what the
precise value of <code>&lt;SomeType as Trait&gt;::Assoc</code> is.</p>
<p>Some examples for the generated goal:</p>
<pre><code class="language-rust ignore">// Trait Program Clauses

// These are program clauses that come from the trait definitions below
// and that the trait solver can use for its reasonings. I'm just restating
// them here so that we have them in mind.

trait Copy { }
// This is a program clause that comes from the trait definition above
// and that the trait solver can use for its reasonings. I'm just restating
// it here (and also the few other ones coming just after) so that we have
// them in mind.
// `WellFormed(Self: Copy) :- Implemented(Self: Copy).`

trait Partial where Self: Copy { }
// ```
// WellFormed(Self: Partial) :-
//     Implemented(Self: Partial) &amp;&amp;
//     WellFormed(Self: Copy).
// ```

trait Complete where Self: Partial { }
// ```
// WellFormed(Self: Complete) :-
//     Implemented(Self: Complete) &amp;&amp;
//     WellFormed(Self: Partial).
// ```

// Impl WF Goals

impl&lt;T&gt; Partial for T where T: Complete { }
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Complete)) {
//         WellFormed(T: Partial)
//     }
// }
// ```
// Then proving `WellFormed(T: Partial)` amounts to proving
// `Implemented(T: Partial)` and `Implemented(T: Copy)`.
// Both those facts can be deduced from the `FromEnv(T: Complete)` in our
// environment: this impl is legal.

impl&lt;T&gt; Complete for T { }
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     WellFormed(T: Complete)
// }
// ```
// Then proving `WellFormed(T: Complete)` amounts to proving
// `Implemented(T: Complete)`, `Implemented(T: Partial)` and
// `Implemented(T: Copy)`.
//
// `Implemented(T: Complete)` can be proved thanks to the
// `impl&lt;T&gt; Complete for T` blanket impl.
//
// `Implemented(T: Partial)` can be proved thanks to the
// `impl&lt;T&gt; Partial for T where T: Complete` impl and because we know
// `T: Complete` holds.

// However, `Implemented(T: Copy)` cannot be proved: the impl is illegal.
// An additional `where T: Copy` bound would be sufficient to make that impl
// legal.
</code></pre>
<pre><code class="language-rust ignore">trait Bar { }

impl&lt;T&gt; Bar for T where &lt;T as Iterator&gt;::Item: Bar { }
// We have a non-parameter type appearing in the where clauses:
// `&lt;T as Iterator&gt;::Item`. The generated goal is:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(&lt;T as Iterator&gt;::Item: Bar)) {
//         WellFormed(T: Bar) &amp;&amp;
//             WellFormed(&lt;T as Iterator&gt;::Item: Bar)
//     }
// }
// ```
// And `WellFormed(&lt;T as Iterator&gt;::Item: Bar)` is not provable: we'd need
// an additional `where T: Iterator` for example.
</code></pre>
<pre><code class="language-rust ignore">trait Foo { }

trait Bar {
    type Item: Foo;
}

struct Stuff&lt;T&gt; { }

impl&lt;T&gt; Bar for Stuff&lt;T&gt; where T: Foo {
    type Item = T;
}
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Foo)) {
//         WellFormed(T: Foo).
//     }
// }
// ```
// which is provable.
</code></pre>
<pre><code class="language-rust ignore">trait Debug { ... }
// `WellFormed(Self: Debug) :- Implemented(Self: Debug).`

struct Box&lt;T&gt; { ... }
impl&lt;T&gt; Debug for Box&lt;T&gt; where T: Debug { ... }

trait PointerFamily {
    type Pointer&lt;T&gt;: Debug where T: Debug;
}
// `WellFormed(Self: PointerFamily) :- Implemented(Self: PointerFamily).`

struct BoxFamily;

impl PointerFamily for BoxFamily {
    type Pointer&lt;T&gt; = Box&lt;T&gt; where T: Debug;
}
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     WellFormed(BoxFamily: PointerFamily) &amp;&amp;
//
//     if (FromEnv(T: Debug)) {
//         WellFormed(Box&lt;T&gt;: Debug) &amp;&amp;
//             WellFormed(Box&lt;T&gt;)
//     }
// }
// ```
// `WellFormed(BoxFamily: PointerFamily)` amounts to proving
// `Implemented(BoxFamily: PointerFamily)`, which is ok thanks to our impl.
//
// `WellFormed(Box&lt;T&gt;)` is always true (there are no where clauses on the
// `Box` type definition).
//
// Moreover, we have an `impl&lt;T: Debug&gt; Debug for Box&lt;T&gt;`, hence
// we can prove `WellFormed(Box&lt;T&gt;: Debug)` and the impl is indeed legal.
</code></pre>
<pre><code class="language-rust ignore">trait Foo {
    type Assoc&lt;T&gt;;
}

struct OnlyClone&lt;T: Clone&gt; { ... }

impl Foo for i32 {
    type Assoc&lt;T&gt; = OnlyClone&lt;T&gt;;
}
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     WellFormed(i32: Foo) &amp;&amp;
//        WellFormed(OnlyClone&lt;T&gt;)
// }
// ```
// however `WellFormed(OnlyClone&lt;T&gt;)` is not provable because it requires
// `Implemented(T: Clone)`. It would be tempting to just add a `where T: Clone`
// bound inside the `impl Foo for i32` block, however we saw that it was
// illegal to add where clauses that didn't come from the trait definition.
</code></pre>
<h1><a class="header" href="#canonical-queries" id="canonical-queries">Canonical queries</a></h1>
<h1><a class="header" href="#canonicalization" id="canonicalization">Canonicalization</a></h1>
<p>Canonicalization is the process of <strong>isolating</strong> an inference value
from its context. It is a key part of implementing
<a href="canonical_queries/../canonical_queries.html">canonical queries</a>, and you may wish to read the parent chapter
to get more context.</p>
<p>Canonicalization is really based on a very simple concept: every
<a href="https://rustc-dev-guide.rust-lang.org/type-inference.html#vars">inference variable</a> 
is always in one of two states: either it is <strong>unbound</strong>, in which case we don't know yet
what type it is, or it is <strong>bound</strong>, in which case we do. So to
isolate some data-structure T that contains types/regions from its
environment, we just walk down and find the unbound variables that
appear in T; those variables get replaced with &quot;canonical variables&quot;,
starting from zero and numbered in a fixed order (left to right, for
the most part, but really it doesn't matter as long as it is
consistent).</p>
<p>So, for example, if we have the type <code>X = (?T, ?U)</code>, where <code>?T</code> and
<code>?U</code> are distinct, unbound inference variables, then the canonical
form of <code>X</code> would be <code>(?0, ?1)</code>, where <code>?0</code> and <code>?1</code> represent these
<strong>canonical placeholders</strong>. Note that the type <code>Y = (?U, ?T)</code> also
canonicalizes to <code>(?0, ?1)</code>. But the type <code>Z = (?T, ?T)</code> would
canonicalize to <code>(?0, ?0)</code> (as would <code>(?U, ?U)</code>). In other words, the
exact identity of the inference variables is not important – unless
they are repeated.</p>
<p>We use this to improve caching as well as to detect cycles and other
things during trait resolution. Roughly speaking, the idea is that if
two trait queries have the same canonical form, then they will get
the same answer. That answer will be expressed in terms of the
canonical variables (<code>?0</code>, <code>?1</code>), which we can then map back to the
original variables (<code>?T</code>, <code>?U</code>).</p>
<h2><a class="header" href="#canonicalizing-the-query" id="canonicalizing-the-query">Canonicalizing the query</a></h2>
<p>To see how it works, imagine that we are asking to solve the following
trait query: <code>?A: Foo&lt;'static, ?B&gt;</code>, where <code>?A</code> and <code>?B</code> are unbound.
This query contains two unbound variables, but it also contains the
lifetime <code>'static</code>. The trait system generally ignores all lifetimes
and treats them equally, so when canonicalizing, we will <em>also</em>
replace any <a href="https://rustc-dev-guide.rust-lang.org/appendix/background.html#free-vs-bound">free lifetime</a> with a
canonical variable (Note that <code>'static</code> is actually a <em>free</em> lifetime 
variable here. We are not considering it in the typing context of the whole 
program but only in the context of this trait reference. Mathematically, we
are not quantifying over the whole program, but only this obligation).
Therefore, we get the following result:</p>
<pre><code class="language-text">?0: Foo&lt;'?1, ?2&gt;
</code></pre>
<p>Sometimes we write this differently, like so:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>This <code>for&lt;&gt;</code> gives some information about each of the canonical
variables within.  In this case, each <code>T</code> indicates a type variable,
so <code>?0</code> and <code>?2</code> are types; the <code>L</code> indicates a lifetime variable, so
<code>?1</code> is a lifetime. The <code>canonicalize</code> method <em>also</em> gives back a
<code>CanonicalVarValues</code> array OV with the &quot;original values&quot; for each
canonicalized variable:</p>
<pre><code class="language-text">[?A, 'static, ?B]
</code></pre>
<p>We'll need this vector OV later, when we process the query response.</p>
<h2><a class="header" href="#executing-the-query" id="executing-the-query">Executing the query</a></h2>
<p>Once we've constructed the canonical query, we can try to solve it.
To do so, we will wind up creating a fresh inference context and
<strong>instantiating</strong> the canonical query in that context. The idea is that
we create a substitution S from the canonical form containing a fresh
inference variable (of suitable kind) for each canonical variable.
So, for our example query:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>the substitution S might be:</p>
<pre><code class="language-text">S = [?A, '?B, ?C]
</code></pre>
<p>We can then replace the bound canonical variables (<code>?0</code>, etc) with
these inference variables, yielding the following fully instantiated
query:</p>
<pre><code class="language-text">?A: Foo&lt;'?B, ?C&gt;
</code></pre>
<p>Remember that substitution S though! We're going to need it later.</p>
<p>OK, now that we have a fresh inference context and an instantiated
query, we can go ahead and try to solve it. The trait solver itself is
explained in more detail in <a href="canonical_queries/../engine/slg.html">another section</a>, but
suffice to say that it will compute a <a href="canonical_queries/../canonical_queries.html#query-response">certainty value</a> (<code>Proven</code> or
<code>Ambiguous</code>) and have side-effects on the inference variables we've
created. For example, if there were only one impl of <code>Foo</code>, like so:</p>
<pre><code class="language-rust ignore">impl&lt;'a, X&gt; Foo&lt;'a, X&gt; for Vec&lt;X&gt;
where X: 'a
{ ... }
</code></pre>
<p>then we might wind up with a certainty value of <code>Proven</code>, as well as
creating fresh inference variables <code>'?D</code> and <code>?E</code> (to represent the
parameters on the impl) and unifying as follows:</p>
<ul>
<li><code>'?B = '?D</code></li>
<li><code>?A = Vec&lt;?E&gt;</code></li>
<li><code>?C = ?E</code></li>
</ul>
<p>We would also accumulate the region constraint <code>?E: '?D</code>, due to the
where clause.</p>
<p>In order to create our final query result, we have to &quot;lift&quot; these
values out of the query's inference context and into something that
can be reapplied in our original inference context. We do that by
<strong>re-applying canonicalization</strong>, but to the <strong>query result</strong>.</p>
<h2><a class="header" href="#canonicalizing-the-query-result" id="canonicalizing-the-query-result">Canonicalizing the query result</a></h2>
<p>As discussed in <a href="canonical_queries/../canonical_queries.html#query-response">the parent section</a>, most trait queries wind up
with a result that brings together a &quot;certainty value&quot; <code>certainty</code>, a
result substitution <code>var_values</code>, and some region constraints. To
create this, we wind up re-using the substitution S that we created
when first instantiating our query. To refresh your memory, we had a query</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>for which we made a substutition S:</p>
<pre><code class="language-text">S = [?A, '?B, ?C]
</code></pre>
<p>We then did some work which unified some of those variables with other things.
If we &quot;refresh&quot; S with the latest results, we get:</p>
<pre><code class="language-text">S = [Vec&lt;?E&gt;, '?D, ?E]
</code></pre>
<p>These are precisely the new values for the three input variables from
our original query. Note though that they include some new variables
(like <code>?E</code>). We can make those go away by canonicalizing again! We don't
just canonicalize S, though, we canonicalize the whole query response QR:</p>
<pre><code class="language-text">QR = {
    certainty: Proven,             // or whatever
    var_values: [Vec&lt;?E&gt;, '?D, ?E] // this is S
    region_constraints: [?E: '?D], // from the impl
    value: (),                     // for our purposes, just (), but
                                   // in some cases this might have
                                   // a type or other info
}
</code></pre>
<p>The result would be as follows:</p>
<pre><code class="language-text">Canonical(QR) = for&lt;T, L&gt; {
    certainty: Proven,
    var_values: [Vec&lt;?0&gt;, '?1, ?0]
    region_constraints: [?0: '?1],
    value: (),
}
</code></pre>
<p>(One subtle point: when we canonicalize the query <strong>result</strong>, we do not
use any special treatment for free lifetimes. Note that both
references to <code>'?D</code>, for example, were converted into the same
canonical variable (<code>?1</code>). This is in contrast to the original query,
where we canonicalized every free lifetime into a fresh canonical
variable.)</p>
<p>Now, this result must be reapplied in each context where needed.</p>
<h2><a class="header" href="#processing-the-canonicalized-query-result" id="processing-the-canonicalized-query-result">Processing the canonicalized query result</a></h2>
<p>In the previous section we produced a canonical query result. We now have
to apply that result in our original context. If you recall, way back in the
beginning, we were trying to prove this query:</p>
<pre><code class="language-text">?A: Foo&lt;'static, ?B&gt;
</code></pre>
<p>We canonicalized that into this:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>and now we got back a canonical response:</p>
<pre><code class="language-text">for&lt;T, L&gt; {
    certainty: Proven,
    var_values: [Vec&lt;?0&gt;, '?1, ?0]
    region_constraints: [?0: '?1],
    value: (),
}
</code></pre>
<p>We now want to apply that response to our context. Conceptually, how
we do that is to (a) instantiate each of the canonical variables in
the result with a fresh inference variable, (b) unify the values in
the result with the original values, and then (c) record the region
constraints for later. Doing step (a) would yield a result of</p>
<pre><code class="language-text">{
      certainty: Proven,
      var_values: [Vec&lt;?C&gt;, '?D, ?C]
                       ^^   ^^^ fresh inference variables
      region_constraints: [?C: '?D],
      value: (),
}
</code></pre>
<p>Step (b) would then unify:</p>
<pre><code class="language-text">?A with Vec&lt;?C&gt;
'static with '?D
?B with ?C
</code></pre>
<p>And finally the region constraint of <code>?C: 'static</code> would be recorded
for later verification.</p>
<p>(What we <em>actually</em> do is a mildly optimized variant of that: Rather
than eagerly instantiating all of the canonical values in the result
with variables, we instead walk the vector of values, looking for
cases where the value is just a canonical variable. In our example,
<code>values[2]</code> is <code>?C</code>, so that means we can deduce that <code>?C := ?B</code> and
<code>'?D := 'static</code>. This gives us a partial set of values. Anything for
which we do not find a value, we create an inference variable.)</p>
<h1><a class="header" href="#chalk-engine" id="chalk-engine">Chalk engine</a></h1>
<p>The <code>chalk-engine</code> crate is the core PROLOG-like solver for logical
predicates. Importantly, it is very general and not specific to Rust,
Rust types, or Rust logic.</p>
<h2><a class="header" href="#implemented-prolog-concepts" id="implemented-prolog-concepts">Implemented PROLOG concepts</a></h2>
<p>The engine implements the following PROLOG logic concepts. Some of these
have been published on previously, and some are <code>Chalk</code>-specific. This isn't
necesarily an exhaustive list:</p>
<ul>
<li>Basic logic</li>
<li>Negation</li>
<li>Floundering</li>
<li>Coinductive solving</li>
</ul>
<h2><a class="header" href="#note" id="note">Note</a></h2>
<p>Throughout most of this chapter, the specifics in regards to
<code>Canonicalization</code> and <code>UCanonicalization</code> are avoided. These are important
concepts to understand, but don't particulary help to understand how
<code>chalk-engine</code> <em>works</em>. In a few places, it may be highlighted if it <em>is</em>
important.</p>
<h1><a class="header" href="#major-concepts" id="major-concepts">Major concepts</a></h1>
<p>This section goes over a few different concepts that are crucial to
understanding how <code>chalk-engine</code> works, without going over the exact solving
logic.</p>
<h2><a class="header" href="#context-contextops-and-inferencetable" id="context-contextops-and-inferencetable"><code>Context</code>, <code>ContextOps</code>, and <code>InferenceTable</code></a></h2>
<h3><a class="header" href="#context" id="context"><code>Context</code></a></h3>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.Context.html"><code>Context</code></a> trait is the primary bridge between Chalk internal logic and
external types. In addition actually <em>defining</em> the types (via associated
types), it also contains associated functions to convert or extract
information from those types. Overall, this allows the types to be basically
opaque to the engine internals. Functions in the trait are agnostic to specific
program or environment details, since they lack a <code>&amp;self</code> argument.</p>
<p>To give an example, there is an associated <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.Context.html#associatedtype.Goal"><code>Goal</code></a> type. However, Chalk doesn't
know how to solve this. Instead, it has to be converted an <code>HhGoal</code> via the
<code>Context::into_hh_goal</code> function. This will be coverted more in the <code>Goals</code>
section.</p>
<h3><a class="header" href="#contextops" id="contextops"><code>ContextOps</code></a></h3>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.ContextOps.html"><code>ContextOps</code></a> trait contains functions that may specifically require
information a specific program or environment. For example, the
<code>program_clauses</code> function gives potential ways to prove a <code>Goal</code>, but obviously
it requires knowing the program (for example, what types, traits, and impls
there are). Functions in this trait all take a <code>&amp;self</code> argument.</p>
<h3><a class="header" href="#inferencetable" id="inferencetable"><code>InferenceTable</code></a></h3>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.InferenceTable.html"><code>InferenceTable</code></a> is a super trait to the <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.UnificationOps.html"><code>UnificationOps</code></a>, <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.TruncateOps.html"><code>TruncateOps</code></a>,
and <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.ResolventOps.html"><code>ResolventOps</code></a>. Each of these contains functions that track the state of
specific parts of the program. Importantly, these operations can dynamically
change the state of the logic itself.</p>
<h2><a class="header" href="#goals" id="goals">Goals</a></h2>
<p>A &quot;goal&quot; in Chalk can be thought of as &quot;something we want to prove&quot;. The engine
itself understands <code>HhGoal</code>s. <code>HHGoal</code>s consist of the most basic logic,
such as introducing Binders (<code>Forall</code> or <code>Exists</code>) or combining goals (<code>All</code>).
On the other hand, <code>Context::Goal</code> represents an opaque goal generated
externally. As such, it may contain any extra information or may be interned.
When solving a logic predicate, Chalk will lazily convert <code>Context::Goal</code>s
into <code>HHGoal</code>s.</p>
<p>There are three types of completely opaque <code>HhGoal</code>s that Chalk can solve:
<code>Unify</code>, <code>DomainGoal</code>, and <code>CannotProve</code>. Unlike the other types of goals,
these three cannot be simiplified any further. <code>Unify</code> is the goal of unifying
any two types. <code>DomainGoal</code> is any goal that can solve by applying a
<a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.Context.html#associatedtype.ProgramClause"><code>ProgramClause</code></a>. To solve this, more <code>Goal</code>s may generated. Finally,
<code>CannotProve</code> is a special goal that <em>cannot</em> be proven true or false.</p>
<h2><a class="header" href="#answers-and-solutions" id="answers-and-solutions">Answers and Solutions</a></h2>
<p>For every <code>Goal</code>, there are zero or more <code>Answer</code>s. Each <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.Answer.html"><code>Answer</code></a> contains
values for the inference variables in the goal.</p>
<p>For example, given the following program:</p>
<pre><code class="language-notrust">trait Clone {}
struct A {}
struct B {}
impl Clone for A {}
impl Clone for B {}
</code></pre>
<p>With the following goal: <code>exists&lt;T&gt; { T: Clone }</code>
The following solutions would be given:</p>
<pre><code class="language-notrust">T = A
T = B
</code></pre>
<p>In other words, either <code>A</code> or <code>B</code> can substituted for <code>T</code> and the goal will
hold true. Moreover, either answer could be used when further solving other
goals that depend on this goal.</p>
<p>However, oftentimes, this is not what external crates want when solving for a
goal. Instead, the may want a <em>unique</em> solution to this goal. Indeed, when we
solve for a given root <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.Context.html#associatedtype.Goal"><code>Goal</code></a>, we return a since <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.Context.html#associatedtype.Solution"><code>Solution</code></a>. It is up to the
implementation of <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.Context.html"><code>Context</code></a> to decide how a <code>Solution</code> is made, given a possibly
infinite set of answers. One of example of this is the
<a href="https://rust-lang.github.io/chalk/chalk_solve/solve/slg/aggregate/struct.AntiUnifier.html"><code>AntiUnifier</code></a>
from <code>chalk-solve</code>, which finds a minimal generalization of answers which don't
unify. (For the example above, it would return only <code>Ambiguous</code>, since <code>A</code> and
<code>B</code> can't unify.)</p>
<h2><a class="header" href="#exclauses-and-strands" id="exclauses-and-strands">ExClauses and Strands</a></h2>
<p>An <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.ExClause.html"><code>ExClause</code></a> is described in literature as <code>A :- D | G</code> or
<code>A holds given that G holds with D delayed goals</code>. In <code>chalk-engine</code>, an
<code>ExClause</code> stores the current state of proving a goal, including existing
substitutions already found, subgoals yet to be proven, or delayed subgoals. A
<a href="https://rust-lang.github.io/chalk/chalk_engine/strand/struct.Strand.html"><code>Strand</code></a> wraps both an <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.ExClause.html"><code>ExClause</code></a> and an <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.InferenceTable.html"><code>InferenceTable</code></a> together. </p>
<h2><a class="header" href="#tables-and-forests" id="tables-and-forests">Tables and Forests</a></h2>
<p>A <a href="https://rust-lang.github.io/chalk/chalk_engine/strand/struct.Strand.html"><code>Strand</code></a> represents a <em>single</em> direction to find an <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.Answer.html"><code>Answer</code></a> - for example, an
implementation of a trait with a set of where clauses. However, in a program,
there may be <em>multiple</em> possible implementations that match a goal - e.g.
multiple impls with different where clauses. Every <a href="https://rust-lang.github.io/chalk/chalk_engine/table/struct.Table.html"><code>Table</code></a> has a goal, and
stores existing <code>Answers</code>, as well as all <code>Strand</code>s that may result in more
answers.</p>
<p>A <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html"><code>Forest</code></a> holds all the <code>Table</code>s that program generates, and is what most of
the logic is implemented on. It also stores the current state of solving (the
stack).</p>
<h1><a class="header" href="#logic" id="logic">Logic</a></h1>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p><code>chalk-engine</code> solves a <code>Goal</code> using a hybrid search strategy with elements of depth- and breadth-first search. When asked to solve a
particular <code>Goal</code> it hasn't seen before, it will first ask the <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.Context.html"><code>Context</code></a> to
generate a set of program clauses, that get turned into <a href="https://rust-lang.github.io/chalk/chalk_engine/strand/struct.Strand.html"><code>Strand</code></a>s, that could
solve that goal. Otherwise, if asked to solve a <code>Goal</code> it has seen before, it
will select the existing table.</p>
<p>Once a table is selected, it will pick a <code>Strand</code> and a subgoal of that
<code>Strand</code>, try to solve that <code>Goal</code>, repeating the process.</p>
<p>When an <code>Answer</code> is found for a <code>Goal</code>, it is merged into the parent <code>Strand</code>,
or returned if it was the root <code>Goal</code>. It will then go on to pick the next
subgoal of the <code>Strand</code> and continue on.</p>
<p>If at any point the solving stops being &quot;successful&quot; (i.e. we definitely found
something to be unsolvable), the solving is restarted at the root <code>Goal</code>.</p>
<h2><a class="header" href="#the-stack" id="the-stack">The stack</a></h2>
<p>In order to detect cycles (talked more about later), as well as keep track of
the selected <a href="https://rust-lang.github.io/chalk/chalk_engine/strand/struct.Strand.html"><code>Strand</code></a> for each table, <code>chalk-engine</code> stores a <a href="https://rust-lang.github.io/chalk/chalk_engine/stack/struct.Stack.html"><code>Stack</code></a> on the
<code>Forest</code>. Whenever a new goal is selected, a <a href="https://rust-lang.github.io/chalk/chalk_engine/stack/struct.StackEntry.html"><code>StackEntry</code></a> is pushed onto the
<code>Stack</code>, as well as the the &quot;time&quot; (which also gets incremented) that it was
pushed. This &quot;time&quot; can be compared later to check if all the <code>Strands</code> of a
<a href="https://rust-lang.github.io/chalk/chalk_engine/table/struct.Table.html"><code>Table</code></a> have been checked in a single solve.</p>
<p>As either <code>Answer</code>s are found for the selected <code>Table</code>, entries on the stack are
<code>pop</code>ed. If something is found to be unsolvable, the complete stack is unwound.</p>
<h2><a class="header" href="#table-creation" id="table-creation">Table creation</a></h2>
<p>As mentioned before, whenever a new <code>Goal</code> is encounted, a new <a href="https://rust-lang.github.io/chalk/chalk_engine/table/struct.Table.html"><code>Table</code></a> is
created to store current and future answers. First, the <a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.Context.html#associatedtype.Goal"><code>Goal</code></a> is converted into
an <code>HhGoal</code>. If it can be simplified, then a <code>Strand</code> with one or more
subgoals will be generated and can be followed as above. Otherwise, if it is a
<code>DomainGoal</code> (see above), then
<a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.ContextOps.html#tymethod.program_clauses"><code>program_clauses</code></a>
is called and each clause is converted into a <code>Strand</code> and can be followed.</p>
<h2><a class="header" href="#root_answer-and-ensure_root_answer" id="root_answer-and-ensure_root_answer"><code>root_answer</code> and <code>ensure_root_answer</code></a></h2>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.root_answer"><code>root_answer</code></a> function is the entry point to solve a <code>Goal</code>. Up until now,
the idea of <code>Answer</code> versus <code>CompleteAnswer</code> have been ignored. However, in
reality <code>Answer</code>s to <code>Goal</code>s may actually have delayed subgoals (see <code>ExClause</code>
and <a href="engine/logic.html#coinduction-and-refinement-strands">Coinduction and refinement strands</a>), whereas <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.CompleteAnswer.html"><code>CompleteAnswer</code></a>s may not.
<code>root_answer</code> essentially just wraps <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> and converts the
<code>Goal</code>'s <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.Answer.html"><code>Answer</code></a> to a <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.CompleteAnswer.html"><code>CompleteAnswer</code></a>.</p>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> function contains the core skeleton of the logic around
<code>Strand</code> and subgoal selection. The majority of the logic, however, is split out
into separate functions that branch out from <code>ensure_root_answer</code>.</p>
<h2><a class="header" href="#subgoal-selection" id="subgoal-selection">Subgoal selection</a></h2>
<p>Once a given <code>Strand</code> for a table has been selected, a subgoal has to be
selected. If there are no subgoals left, then there is nothing to do. Otherwise,
if there are subgoals left, then a subgoal will attempt to be selected (from
<a href="https://rust-lang.github.io/chalk/chalk_engine/context/trait.Context.html#tymethod.next_subgoal_index"><code>next_subgoal_index</code></a>).
If the table for that subgoal had previously floundered (see next section), then
we mark that subgoal as floundered and try the next subgoal. If all subgoals are
marked as floundered, then this entire <code>Strand</code> is marked as floundered. If a
subgoal is successfully selected, there is nothing left to do.</p>
<h2><a class="header" href="#floundering" id="floundering">Floundering</a></h2>
<p>There a couple cases where we &quot;give up&quot; - here called floundering - on trying to
solve a goal. The most easy to understand case is if the types for a <code>Goal</code> or
<code>Answer</code> are too large. (Side note, we <em>could</em> actually handle this - by
generalizing - but turns out to be quite buggy and probably unnecessary).
Another case where we flounder is if we try to solve a <code>Goal</code> where we try to
<strong>enumerate</strong> non-enumerable types (like auto traits). In general, floundering
just means that we <em>can't</em> know any more answers about a <code>Goal</code>, for some
reason. However, if there are other <code>Strands</code> that don't flounder, there may
still be other <code>Answer</code>s available.</p>
<h2><a class="header" href="#answers" id="answers">Answers</a></h2>
<p>After an answer has been found for a subgoal, it must be <em>applied</em> to the parent
<code>Strand</code>. Specifically, it must be able to unify with any existing <code>Answers</code>. If
the <code>Answer</code>s are incompatible, the <code>Strand</code> is dropped since it can't lead
anywhere.</p>
<h2><a class="header" href="#cycles" id="cycles">Cycles</a></h2>
<p>If while pursuing a <code>Goal</code>, the engine encounters the same <code>Table</code> twice, then a
cycle has occured. If the cycle is not coinductive (see next), then there is
nothing that can be gained from taking this route. We mark how far up the stack
is in the cycle, and try the next <code>Strand</code>. If all <code>Strand</code>s for a table
encounter a cycle, then we know that the current selected <code>Goal</code> has no more
answers.</p>
<h2><a class="header" href="#coinduction-and-refinement-strands" id="coinduction-and-refinement-strands">Coinduction and refinement strands</a></h2>
<p>Coinduction basically means that two statements can rely on each other being
true, unless either is proven false.</p>
<p>For example with the following program:</p>
<pre><code class="language-notrust">#[coinductive]
trait C1&lt;T&gt; { }
forall&lt;A, B&gt; { A: C1&lt;B&gt; if B: C1&lt;A&gt; }
</code></pre>
<p>Then the goal <code>exists&lt;T, U&gt; { T: C1&lt;U&gt; }</code> holds for all <code>T</code> and <code>U</code>. If the <code>C1</code>
trait was not coinductive, this would be a simple cycle.</p>
<p>To implement coinduction in the engine, delayed subgoals were introduced.
Essentially, if a cycle is found, and the <code>Goal</code> is coinductive, then this is
&quot;delayed&quot; until the stack unwinds back to the top <code>Goal</code> and all other
non-coinductive cycles have been proven. Then, <code>Goal</code> has been proven itself. In
some cases, it is the <em>root</em> <code>Goal</code> that has delayed coinductive subgoals (see
above example). In this case, we create another &quot;Refinement Strand&quot; where the
only subgoals are the delayed coinductive subgoals. If this new <code>Strand</code> can be
proven, then any <code>Answer</code>s from that are valid answers for the root <code>Goal</code>.
However, since there are currently delayed coinductive subgoals, there are no
answers available yet.</p>
<p>For much more in-depth </p>
<h1><a class="header" href="#coinduction" id="coinduction">Coinduction</a></h1>
<p>This sub-chapter was originally prepared for wg-traits design meeting on 2019-11-08 (see the <a href="https://hackmd.io/OJRi5OM6Twunw8ZmuLxfRA">Hackmd</a> doc). It briefly covers some tricky (and previously incorrectly handled) cases of coinduction, as well as two proposed solutions. The resulting and current solution ended up being something <em>pretty</em> close to Niko's solution. However, this is basically a copy-paste from the original document, and so shouldn't necessarily be taken as 100% truth as far as implementation.</p>
<h2><a class="header" href="#the-problem" id="the-problem">The problem</a></h2>
<p>See <a href="https://github.com/rust-lang/chalk/issues/248">chalk#248</a> for details. The short version is that we fail to handle a case like this correctly, where <code>Ci</code> are all co-inductive goals:</p>
<pre><code class="language-notrust">C1 :- C2, C3.
C2 :- C1.
</code></pre>
<p>What happens is that we </p>
<ul>
<li>start to prove C1</li>
<li>start to prove C2</li>
<li>see a recursive attempt to prove C1, assume it is succesful</li>
<li>consider C2 proved <strong>and cache this</strong></li>
<li>start to prove C3, fail</li>
<li>consider C1 <strong>unproven</strong></li>
</ul>
<p>Now we incorrectly have a result that <code>C2</code> is true -- but that result was made on the assumption that <code>C1</code> was true, and it was not.</p>
<h2><a class="header" href="#some-other-tricky-cases-to-consider" id="some-other-tricky-cases-to-consider">Some other tricky cases to consider</a></h2>
<h3><a class="header" href="#unification-failures" id="unification-failures">Unification failures</a></h3>
<p>One thing to consider is that even when we have &quot;coinduction obligations&quot; to prove, we have to remember their substitutions too:</p>
<pre><code class="language-notrust">C1(X) :- C2(Y), X = 22.
C2(X) :- C3(X), X = 44.
C3(X) :- C1(X), C2(X).
</code></pre>
<p>None of these predicates should be provable,  because <code>C1(X)</code> and <code>C2(X)</code> don't hold for the same <code>X</code>.</p>
<p>If we're not careful, we might:</p>
<ul>
<li>start to prove C1</li>
<li>start to prove C2</li>
<li>start to prove C3, see the recursive calls to C1 and C2
<ul>
<li>maybe we wait to consider it proven until C1 and C2 complete</li>
</ul>
</li>
</ul>
<p>In this case, it's not enough that C1 and C2 are provable at all, they have to be provable for the same X.</p>
<h3><a class="header" href="#non-trivial-self-cycles" id="non-trivial-self-cycles">Non-trivial self-cycles</a></h3>
<pre><code class="language-notrust">C1(A) :- C1(B), B = 22, C2(A).
C2(44).
</code></pre>
<p>This case is not provable, even though the only cycle is <code>C1(X) :- C1(Y)</code> -- but it turns out that <code>X</code> must not be 22. The catch is that while this might <em>appear</em> to be a trivial self-cycle, it is not! </p>
<p>Actually I have to think about the best way to handle this case, as my proposed solution doesn't quite cut it. It wouldn't be <em>wrong</em> but it seems not ideal. -- Niko</p>
<h3><a class="header" href="#delayed-trivial-cycles" id="delayed-trivial-cycles">Delayed trivial cycles</a></h3>
<pre><code class="language-notrust">C1(A, B) :- C2(A, B), A = 22, B = 22.
C2(A, B) :- C1(B, A).
</code></pre>
<p>This should be provable, but the cycle from C2 to C1 is not immediately visible as a trivial cycle, at least if subgoals are solved in order.</p>
<h3><a class="header" href="#delayed-trivial-cycles-variant-2" id="delayed-trivial-cycles-variant-2">Delayed trivial cycles, variant 2</a></h3>
<pre><code class="language-notrust">C1(A, B) :- C2(A, B), A = 22.
C2(A, B) :- C1(B, A).
</code></pre>
<p>As above, here the only complete answer is <code>C1(22, 22)</code>. This is because the <code>C1</code>, <code>C2</code> cycle effectively guarantees equality.</p>
<h3><a class="header" href="#delayed-trivial-cycles-variant-3" id="delayed-trivial-cycles-variant-3">Delayed trivial cycles, variant 3</a></h3>
<pre><code class="language-notrust">C1(A, B) :- C1(B, A).
</code></pre>
<p>This is true for all <code>A, B</code></p>
<h3><a class="header" href="#other-cases" id="other-cases">Other cases?</a></h3>
<h2><a class="header" href="#approach-in-existing-pr" id="approach-in-existing-pr">Approach in existing PR</a></h2>
<h3><a class="header" href="#high-level-idea" id="high-level-idea">High-level idea</a></h3>
<ul>
<li>When we encounter a co-inductive subgoal, we delay them in the current <code>Strand</code></li>
<li>When all subgoals have been tested, and there are remaining delayed co-inductive subgoals, this is propogated up, marking the current <code>Strand</code> as co-inductive</li>
<li>When the co-inductive <code>Strand</code>s reach the root table, we only then pursue an answer</li>
</ul>
<h2><a class="header" href="#nikos-proposed-solution" id="nikos-proposed-solution">Niko's proposed solution</a></h2>
<h3><a class="header" href="#high-level-idea-1" id="high-level-idea-1">High-level idea</a></h3>
<ul>
<li>We only consider a co-induction subgoal proven for <em>trivial</em> recursion -- i.e., self-recursion where you have <code>C1 :- C1</code>.</li>
<li>For non-trivial recursion, we propagate the co-inductive subgoal to the parent. This continues until it becomes trivial.</li>
</ul>
<h3><a class="header" href="#implementation-steps" id="implementation-steps">Implementation steps</a></h3>
<p><strong>Extend <code>Answer</code> in two ways.</strong></p>
<p>Currently <code>Answer</code> has a &quot;constrained substitution&quot; that includes values for the table's substitution + region constraints:</p>
<pre><code class="language-notrust">struct Answer {
    constrained_subst: Canonical&lt;ConstrainedSubst&gt;,
    is_ambiguous: bool
}

struct ConstrainedSubst {
    substitution: Substitution,
    region_constraints: Vec&lt;RegionConstraint&gt;,
}
</code></pre>
<p>we would first extend <code>ConstrainedSubst</code> to include as yet unproven co-inductive subgoals (this might actually be better done as a new type): </p>
<pre><code class="language-rust ignore">struct ConstrainedSubst {
    substitution: Substitution,
    delayed_subgoals: Vec&lt;Literal&gt;,
    region_constraints: Vec&lt;RegionConstraint&gt;,
}
</code></pre>
<p>then we would extend <code>Answer</code> slightly as well so it can be &quot;ok&quot; or ambiguous, as today, but also an <em>error</em> case</p>
<pre><code class="language-rust ignore">enum AnswerMode {
    OK,
    Ambiguous,
    Error,
}

struct Answer {
    constrained_subst: Canonical&lt;ConstrainedSubst&gt;,
    mode: AnswerMode
}
</code></pre>
<p>We won't need this error case till later, so let's ignore it for now. (And in a way, we never need it.)</p>
<p><strong>Deferring coinductive subgoals</strong></p>
<p>When we encounter a co-inductive subgoal, we check if it is <strong>trivial cycle</strong> or not. A trivial cycle is a case like <code>C1 :- C1</code>. We can simply consider such cycles to be true (but note the distinction between a <em>trivial</em> cycle and a <em>self-cycle</em> -- see the &quot;non-trivial self-cycle&quot; example above).</p>
<p>For non-trivial cycles, we will want to store the cycle to be validated later. To accommodate that, we extend <code>ExClause</code> to include a <code>delayed_subgoals</code> list as well. We can write this the same way SLG does, so <code>Goal :- DelayedSubgoals | Subgoals</code></p>
<p>In our example, proving <code>C2 :- C1</code> would result in adding <code>C1</code> to the list of delayed subgoals.</p>
<p>When we reach the end of the list of subgoals, we can create an answer that contains the delayed subgoals. We don't have to add all the goals -- we can check for those that are trivial self-cycles again and remove them (in some cases, something which was not trivial to start may have become trivial through later unifications, see Delayed Trivial Self-Cycle case). Note that we <em>do</em> have to add all non-trivial cycles, including non-trivial self-cycles -- see the walkthrough of Non-trivial self-cycle variant 3.</p>
<p>So the answer to <code>C2</code> would be</p>
<pre><code class="language-notrust">substitution: [] // no variables
delayed_subgoals: [&quot;C1&quot;]
region_constraints: []
</code></pre>
<p>We can denote this as <code>C2 :- C1 |</code>, to use SLG notation.</p>
<p><strong>Incorporating an answer with deferred subgoals.</strong></p>
<p>When a table gets back an answer that has deferred sub-goals, they get added to the current list of subgoals. </p>
<p>So e.g. in our case, we had a <code>ExClause</code> like:</p>
<pre><code class="language-notrust">C1 :- | C2, C3
</code></pre>
<p>and we get the answer <code>C2 :- C1 |</code>, so we would convert it to</p>
<pre><code class="language-notrust">C1 :- | C3, C1
</code></pre>
<p>i.e., we have added <code>C1</code> to the list of goals to prove. When we go to prove <code>C3</code>, of course, we will fail -- but it had succeeded, we would go on to prove <code>C1</code> but encounter a trivial cycle and hence succeed.</p>
<p><strong>Extending root answer</strong></p>
<p>So we failed to prove C1, but we do have a (conditional) answer to C2 -- <code>C2 :- C1 |</code>, even though <code>C2</code> is unprovable. What happens if <code>ensure_root_answer</code> is invoked on <code>C2</code>?</p>
<p>What we have here is a <em>conditional</em> answer. We know that <code>C1</code> must have ultimately resolved itself somehow (although it might not yet be proven). What we can do is create a strand in C2 to evaluate C1 again -- if this strand succeeds, it can actually overwrite the <code>C2 :- C1 |</code> answer in place with <code>C2 :-</code> (i.e., an unconditional answer). This is just a refinement of what we had. If the strand fails, though, we'll want to remember the error.</p>
<p>I think when we get a new answer, we want it to <em>overwrite</em> the old answer in place, rather than create a new answer. This is valid because it's not a new answer, it's just a more refined form of the old answer (although note that it might have different substitutions and other details, see the &quot;delayed trivial cycle&quot; case).</p>
<p>In particular, it could be that the table already has a &quot;complete&quot; set of answers -- i.e., somebody invoked <code>ensure_answer(N)</code> and got back <code>None</code>. We don't want to be adding new answers which would change the result of that call. It <em>is</em> a bit strange that we are changing the result of <code>ensure_answer(i)</code> for the current <code>i</code>, but then the result is the same answer, just a bit more elaborated.</p>
<p>The idea then would be to create a strand <em>associated with this answer somehow</em> (it doesn't, I don't think, live in the normal strand table; we probably have a separate &quot;refinment strand&quot; table). This strand has as its subgoals the delayed subgoals. It pursues them. This either results in an answer (which replaces the existing answer) or an error (in which case the existing answer is marked as <em>error</em>). This may require extending strand with an optional answer index that it should overwrite, or perhaps we thread it down as an argument to <code>pursue_strand</code> (optional because, in the normal mode, we are just appending a new answer).</p>
<p>(Question: What distinguishes root answer? Nothing -- we could actually do this process for any answer, so long as the delayed subgoals are not to tables actively on the stack. This just happens to be trivially true for root answers. The key part though is that the answer must be registered in the table first before the refinement strand is created, see Delayed Self-Cycle Variant 3.)</p>
<p>This is complex, so let's walk through an example or two.</p>
<p><strong>The original problem.</strong> When we finish solving <code>C1</code>, we leave <code>C2</code> with a single answer <code>C2 :- C1 |</code>. If someone  invokes <code>ensure_root_answer(C2, 0)</code>, we would see the delayed literal and create a refinement strand for the answer: <code>C2 :- | C1</code>. We would pursue <code>C1</code> and get back the successful answer. So the refinement strand would terminate and we can overwrite with the answer <code>C2 :- |</code>.</p>
<p><strong>Delayed trivial self-cycle.</strong> Similar to above, but the answer is <code>C2(?A, ?B) :- C1(?B, ?A) |</code>. In other words, in the canonical answer, we have a (identity) substitution of <code>[^0, ^1]</code> and a delayed goal of <code>C1(^1, ^0)</code>. The strand we create will find only one answer to <code>C1</code>, <code>C1(22, 22)</code>, so we wind up with an answer <code>C2(22, 22)</code>.</p>
<p><strong>Handling error answers</strong></p>
<p>We introduced the idea of an &quot;error answer&quot;...how do we handle that? It's fairly simple. If a strand encounters an error answer, it simply fails. Done. The <em>outer</em> search however needs to treat an error answer as basically a no-op -- so e.g. the answer iterator should simply increment the error counter and move to the next answer.</p>
<h3><a class="header" href="#walk-through-delayed-trivial-self-cycle-variant-2" id="walk-through-delayed-trivial-self-cycle-variant-2">Walk through: delayed trivial self cycle, variant 2</a></h3>
<pre><code class="language-notrust">C1(A, B) :- C2(A, B), A = 22.
C2(A, B) :- C1(B, A).
</code></pre>
<ul>
<li><code>ensure_root_answer(C1(?A, ?B))</code> is invoked
<ul>
<li>We start solving <code>C1(?A, ?B)</code> with the ex-clause <code>C1(?A, ?B) :- | C2(?A, ?B), ?A = 22</code>
<ul>
<li>That starts solving <code>C2(?A, ?B)</code>
<ul>
<li>This gets an answer <code>C2(?A, ?B) :- C1(?B, ?A) |</code></li>
<li>When answer is incorporated, we get <code>C1(?A, ?B) :- | C1(?B, ?A), ?A = 22</code></li>
</ul>
</li>
<li><code>C1(?B, ?A)</code> is a non-trivial cycle, and so we get 
<ul>
<li><code>C1(?A, ?B) :- C1(?B, ?A) | ?A = 22</code></li>
</ul>
</li>
<li>Unification completes, leaving us with
<ul>
<li><code>C1(22, ?B) :- C1(?B, 22) |</code></li>
</ul>
</li>
<li>This is a complete answer</li>
</ul>
</li>
<li>ensure root answer attempts to refine this answer, creating a strand for <code>C1(22, ?B) :- | C1(?B, 22)</code>
<ul>
<li>This creates a table for <code>C1(?B, 22)</code> with ex-clause <code>C1(?B, 22) :- | C2(?B, 22), ?B = 22</code>
<ul>
<li>We start solving <code>C2(?B, 22)</code>, which has ex-clause <code>C2(?B, 22) :- C1(22, ?B)</code>
<ul>
<li>This creates a table for <code>C1(22, ?B)</code>, with ex-clause <code>C1(22, ?B) :- C2(22, ?B), 22 = 22</code>
<ul>
<li>This starts solving <code>C2(22, ?B)</code>, which is a fresh table with ex-clause <code>C2(22, ?B) :- C1(?B, 22)</code>
<ul>
<li>This is a co-inductive cycle</li>
<li>So our answer is <code>C2(22, ?B) :- C1(?B, 22) |</code></li>
</ul>
</li>
<li>Incorporating this answer yields <code>C1(22, ?B) :- 22 = 22, C1(?B, 22)</code></li>
<li>The unification constraint succeeds, leaving <code>C1(22, ?B) :- C1(?B, 22)</code></li>
<li>Co-inductive cycle detected, so answer is
<ul>
<li><code>C1(22, ?B) :- C1(?B, 22) |</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>This answer is incorporated into <code>C2</code>, yielding the ex-clause
<ul>
<li><code>C2(?B, 22) :- C1(?B, 22)</code></li>
</ul>
</li>
<li>Pursuing that sub-goal gives a co-inductive cycle, so our final answer is
<ul>
<li><code>C2(?B, 22) :- C1(?B, 22) |</code></li>
</ul>
</li>
</ul>
</li>
<li>This answer is incorporated, yielding ex-clause <code>C1(?B, 22) :- | ?B = 22, C1(?B, 22)</code></li>
<li>Unification yields <code>C1(22, 22) :- C1(22, 22)</code></li>
<li>Trivial self-cycle detected, so final answer is
<ul>
<li><code>C1(22, 22)</code></li>
</ul>
</li>
</ul>
</li>
<li>the answer for <code>C1(?A, ?B)</code> is thus updated to <code>C1(22, 22)</code></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#walk-through-delayed-trivial-self-cycle-variant-3" id="walk-through-delayed-trivial-self-cycle-variant-3">Walk through: delayed trivial self cycle, variant 3</a></h3>
<pre><code class="language-notrust">C1(A, B) :- C1(B, A).
</code></pre>
<p>This example is interesting because it shows that we have to incorporate non-trivial self cycles into an answer so they can recursively build on one another.</p>
<ul>
<li>we get an initial answer of
<ul>
<li><code>C1(?A, ?B) :- C1(?B, ?A) |</code></li>
</ul>
</li>
<li>if we attempt to refine this, we will get a strand <code>C1(?X, ?Y) :- C1(?Y, ?X)</code>
<ul>
<li>pursuing the first subgoal <code>C1(?Y, ?X)</code> leads us to our own table, but at answer 0
<ul>
<li>(the very answer we are refining)</li>
<li>the answer is <code>C1(?Y, ?X) :- C1(?X, ?Y) |</code></li>
</ul>
</li>
<li>this strand incorporates its own answer, yielding
<ul>
<li><code>C1(?X, ?Y) :- C1(?X, ?Y)</code></li>
</ul>
</li>
<li>next subgoal is a trivial self-cycle, discard, yielding
<ul>
<li><code>C1(?X, ?Y) :-</code></li>
</ul>
</li>
</ul>
</li>
<li>result: true</li>
</ul>
<h3><a class="header" href="#walk-through-non-trivial-self-cycle" id="walk-through-non-trivial-self-cycle">Walk through: non-trivial self cycle</a></h3>
<p>Let's walk through one more case, the non-trivial self cycle.</p>
<pre><code class="language-notrust">C1(A) :- C1(B), B = 22, C2(A).
C2(44).
</code></pre>
<p>What happens here is that we get an initial answer from <code>C1</code> that looks like:</p>
<pre><code class="language-notrust">C1(44) :- C1(22) |
</code></pre>
<p>Ensure root answer will thus try to refine by trying to solve <code>C1(22)</code>. Interestingly, this is going to go to a distinct table, because the canonical form is not the same, but that table will just fail.</p>
<h1><a class="header" href="#the-on-demand-slg-solver" id="the-on-demand-slg-solver">The On-Demand SLG solver</a></h1>
<p>Given a set of program clauses (provided by our <a href="engine/../clauses.html">lowering rules</a>)
and a query, we need to return the result of the query and the value of any
type variables we can determine. This is the job of the solver.</p>
<p>For example, <code>exists&lt;T&gt; { Vec&lt;T&gt;: FromIterator&lt;u32&gt; }</code> has one solution, so
its result is <code>Unique; substitution [?T := u32]</code>. A solution also comes with
a set of region constraints, which we'll ignore in this introduction.</p>
<h2><a class="header" href="#goals-of-the-solver" id="goals-of-the-solver">Goals of the Solver</a></h2>
<h3><a class="header" href="#on-demand" id="on-demand">On demand</a></h3>
<p>There are often many, or even infinitely many, solutions to a query. For
example, say we want to prove that <code>exists&lt;T&gt; { Vec&lt;T&gt;: Debug }</code> for <em>some</em>
type <code>?T</code>. Our solver should be capable of yielding one answer at a time, say
<code>?T = u32</code>, then <code>?T = i32</code>, and so on, rather than iterating over every type
in the type system. If we need more answers, we can request more until we are
done. This is similar to how Prolog works.</p>
<p><em>See also: <a href="engine/../canonical_queries.html#the-traditional-interactive-prolog-query">The traditional, interactive Prolog query</a></em></p>
<h3><a class="header" href="#breadth-first" id="breadth-first">Breadth-first</a></h3>
<p><code>Vec&lt;?T&gt;: Debug</code> is true if <code>?T: Debug</code>. This leads to a cycle: <code>[Vec&lt;u32&gt;, Vec&lt;Vec&lt;u32&gt;&gt;, Vec&lt;Vec&lt;Vec&lt;u32&gt;&gt;&gt;]</code>, and so on all implement <code>Debug</code>. Our
solver ought to be breadth first and consider answers like <code>[Vec&lt;u32&gt;: Debug, Vec&lt;i32&gt;: Debug, ...]</code> before it recurses, or we may never find the answer
we're looking for.</p>
<h3><a class="header" href="#cachable" id="cachable">Cachable</a></h3>
<p>To speed up compilation, we need to cache results, including partial results
left over from past solver queries.</p>
<h2><a class="header" href="#description-of-how-it-works" id="description-of-how-it-works">Description of how it works</a></h2>
<p>The basis of the solver is the <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html"><code>Forest</code></a> type. A <em>forest</em> stores a
collection of <em>tables</em> as well as a <em>stack</em>. Each <em>table</em> represents
the stored results of a particular query that is being performed, as
well as the various <em>strands</em>, which are basically suspended
computations that may be used to find more answers. Tables are
interdependent: solving one query may require solving others.</p>
<h3><a class="header" href="#walkthrough-1" id="walkthrough-1">Walkthrough</a></h3>
<p>Perhaps the easiest way to explain how the solver works is to walk
through an example. Let's imagine that we have the following program:</p>
<pre><code class="language-rust ignore">trait Debug { }

struct u32 { }
impl Debug for u32 { }

struct Rc&lt;T&gt; { }
impl&lt;T: Debug&gt; Debug for Rc&lt;T&gt; { }

struct Vec&lt;T&gt; { }
impl&lt;T: Debug&gt; Debug for Vec&lt;T&gt; { }
</code></pre>
<p>Now imagine that we want to find answers for the query <code>exists&lt;T&gt; { Rc&lt;T&gt;: Debug }</code>. The first step would be to u-canonicalize this query; this is the
act of giving canonical names to all the unbound inference variables based on
the order of their left-most appearance, as well as canonicalizing the
universes of any universally bound names (e.g., the <code>T</code> in <code>forall&lt;T&gt; { ... }</code>). In this case, there are no universally bound names, but the canonical
form Q of the query might look something like:</p>
<pre><code class="language-text">Rc&lt;?0&gt;: Debug
</code></pre>
<p>where <code>?0</code> is a variable in the root universe U0. We would then go and
look for a table with this canonical query as the key: since the forest is
empty, this lookup will fail, and we will create a new table T0,
corresponding to the u-canonical goal Q.</p>
<p><strong>Ignoring negative reasoning and regions.</strong> To start, we'll ignore
the possibility of negative goals like <code>not { Foo }</code>. We'll phase them
in later, as they bring several complications.</p>
<p><strong>Creating a table.</strong> When we first create a table, we also initialize
it with a set of <em>initial strands</em>. A &quot;strand&quot; is kind of like a
&quot;thread&quot; for the solver: it contains a particular way to produce an
answer. The initial set of strands for a goal like <code>Rc&lt;?0&gt;: Debug</code>
(i.e., a &quot;domain goal&quot;) is determined by looking for <em>clauses</em> in the
environment. In Rust, these clauses derive from impls, but also from
where-clauses that are in scope. In the case of our example, there
would be three clauses, each coming from the program. Using a
Prolog-like notation, these look like:</p>
<pre><code class="language-text">(u32: Debug).
(Rc&lt;T&gt;: Debug) :- (T: Debug).
(Vec&lt;T&gt;: Debug) :- (T: Debug).
</code></pre>
<p>To create our initial strands, then, we will try to apply each of
these clauses to our goal of <code>Rc&lt;?0&gt;: Debug</code>. The first and third
clauses are inapplicable because <code>u32</code> and <code>Vec&lt;?0&gt;</code> cannot be unified
with <code>Rc&lt;?0&gt;</code>. The second clause, however, will work.</p>
<p><strong>What is a strand?</strong> Let's talk a bit more about what a strand <em>is</em>. In the code, a strand
is the combination of an inference table, an <em>X-clause</em>, and (possibly)
a selected subgoal from that X-clause. But what is an X-clause
(<a href="https://rust-lang.github.io/chalk/chalk_engine/struct.ExClause.html"><code>ExClause</code></a>, in the code)? An X-clause pulls together a few things:</p>
<ul>
<li>The current state of the goal we are trying to prove;</li>
<li>A set of subgoals that have yet to be proven;</li>
<li>There are also a few things we're ignoring for now:
<ul>
<li>delayed literals, region constraints</li>
</ul>
</li>
</ul>
<p>The general form of an X-clause is written much like a Prolog clause,
but with somewhat different semantics. Since we're ignoring delayed
literals and region constraints, an X-clause just looks like this:</p>
<pre><code class="language-text">G :- L
</code></pre>
<p>where G is a goal and L is a set of subgoals that must be proven.
(The L stands for <em>literal</em> -- when we address negative reasoning, a
literal will be either a positive or negative subgoal.) The idea is
that if we are able to prove L then the goal G can be considered true.</p>
<p>In the case of our example, we would wind up creating one strand, with
an X-clause like so:</p>
<pre><code class="language-text">(Rc&lt;?T&gt;: Debug) :- (?T: Debug)
</code></pre>
<p>Here, the <code>?T</code> refers to one of the inference variables created in the
inference table that accompanies the strand. (I'll use named variables
to refer to inference variables, and numbered variables like <code>?0</code> to
refer to variables in a canonicalized goal; in the code, however, they
are both represented with an index.)</p>
<p>For each strand, we also optionally store a <em>selected subgoal</em>. This
is the subgoal after the turnstile (<code>:-</code>) that we are currently trying
to prove in this strand. Initially, when a strand is first created,
there is no selected subgoal.</p>
<p><strong>Activating a strand.</strong> Now that we have created the table T0 and
initialized it with strands, we have to actually try and produce an answer.
We do this by invoking the <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> operation on the table:
specifically, we say <code>ensure_root_answer(T0, A0)</code>, meaning &quot;ensure that there
is a 0th answer A0 to query T0&quot;.</p>
<p>Remember that tables store not only strands, but also a vector of cached
answers. The first thing that <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> does is to check whether
answer A0 is in this vector. If so, we can just return immediately. In this
case, the vector will be empty, and hence that does not apply (this becomes
important for cyclic checks later on).</p>
<p>When there is no cached answer, <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> will try to produce one.
It does this by selecting a strand from the set of active strands -- the
strands are stored in a <code>VecDeque</code> and hence processed in a round-robin
fashion. Right now, we have only one strand, storing the following X-clause
with no selected subgoal:</p>
<pre><code class="language-text">(Rc&lt;?T&gt;: Debug) :- (?T: Debug)
</code></pre>
<p>When we activate the strand, we see that we have no selected subgoal,
and so we first pick one of the subgoals to process. Here, there is only
one (<code>?T: Debug</code>), so that becomes the selected subgoal, changing
the state of the strand to:</p>
<pre><code class="language-text">(Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A0)
</code></pre>
<p>Here, we write <code>selected(L, An)</code> to indicate that (a) the literal <code>L</code>
is the selected subgoal and (b) which answer <code>An</code> we are looking for. We
start out looking for <code>A0</code>.</p>
<p><strong>Processing the selected subgoal.</strong> Next, we have to try and find an
answer to this selected goal. To do that, we will u-canonicalize it
and try to find an associated table. In this case, the u-canonical
form of the subgoal is <code>?0: Debug</code>: we don't have a table yet for
that, so we can create a new one, T1. As before, we'll initialize T1
with strands. In this case, there will be three strands, because all
the program clauses are potentially applicable. Those three strands
will be:</p>
<ul>
<li><code>(u32: Debug) :-</code>, derived from the program clause <code>(u32: Debug).</code>.
<ul>
<li>Note: This strand has no subgoals.</li>
</ul>
</li>
<li><code>(Vec&lt;?U&gt;: Debug) :- (?U: Debug)</code>, derived from the <code>Vec</code> impl.</li>
<li><code>(Rc&lt;?U&gt;: Debug) :- (?U: Debug)</code>, derived from the <code>Rc</code> impl.</li>
</ul>
<p>We can thus summarize the state of the whole forest at this point as
follows:</p>
<pre><code class="language-text">Table T0 [Rc&lt;?0&gt;: Debug]
  Strands:
    (Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A0)

Table T1 [?0: Debug]
  Strands:
    (u32: Debug) :-
    (Vec&lt;?U&gt;: Debug) :- (?U: Debug)
    (Rc&lt;?V&gt;: Debug) :- (?V: Debug)
</code></pre>
<p><strong>Delegation between tables.</strong> Now that the active strand from T0 has
created the table T1, it can try to extract an answer. It does this
via that same <code>ensure_answer</code> operation we saw before. In this case,
the strand would invoke <code>ensure_answer(T1, A0)</code>, since we will start
with the first answer. This will cause T1 to activate its first
strand, <code>u32: Debug :-</code>.</p>
<p>This strand is somewhat special: it has no subgoals at all. This means
that the goal is proven. We can therefore add <code>u32: Debug</code> to the set
of <em>answers</em> for our table, calling it answer A0 (it is the first
answer). The strand is then removed from the list of strands.</p>
<p>The state of table T1 is therefore:</p>
<pre><code class="language-text">Table T1 [?0: Debug]
  Answers:
    A0 = [?0 = u32]
  Strand:
    (Vec&lt;?U&gt;: Debug) :- (?U: Debug)
    (Rc&lt;?V&gt;: Debug) :- (?V: Debug)
</code></pre>
<p>Note that I am writing out the answer A0 as a substitution that can be
applied to the table goal; actually, in the code, the goals for each
X-clause are also represented as substitutions, but in this exposition
I've chosen to write them as full goals, following <a href="engine/../bibliography.html#slg">NFTD</a>.</p>
<p>Since we now have an answer, <code>ensure_answer(T1, A0)</code> will return <code>Ok</code>
to the table T0, indicating that answer A0 is available. T0 now has
the job of incorporating that result into its active strand. It does
this in two ways. First, it creates a new strand that is looking for
the next possible answer of T1. Next, it incorpoates the answer from
A0 and removes the subgoal. The resulting state of table T0 is:</p>
<pre><code class="language-text">Table T0 [Rc&lt;?0&gt;: Debug]
  Strands:
    (Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A1)
    (Rc&lt;u32&gt;: Debug) :-
</code></pre>
<p>We then immediately activate the strand that incorporated the answer
(the <code>Rc&lt;u32&gt;: Debug</code> one). In this case, that strand has no further
subgoals, so it becomes an answer to the table T0. This answer can
then be returned up to our caller, and the whole forest goes quiescent
at this point (remember, we only do enough work to generate <em>one</em>
answer). The ending state of the forest at this point will be:</p>
<pre><code class="language-text">Table T0 [Rc&lt;?0&gt;: Debug]
  Answer:
    A0 = [?0 = u32]
  Strands:
    (Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A1)

Table T1 [?0: Debug]
  Answers:
    A0 = [?0 = u32]
  Strand:
    (Vec&lt;?U&gt;: Debug) :- (?U: Debug)
    (Rc&lt;?V&gt;: Debug) :- (?V: Debug)
</code></pre>
<p>Here you can see how the forest captures both the answers we have
created thus far <em>and</em> the strands that will let us try to produce
more answers later on.</p>
<h2><a class="header" href="#see-also" id="see-also">See also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/chalk/blob/239e4ae4e69b2785b5f99e0f2b41fc16b0b4e65e/chalk-engine/src/README.md">chalk_solve README</a>, which contains links to papers used and
acronyms referenced in the code</li>
<li>This section is a lightly adapted version of the blog post <a href="http://smallcultfollowing.com/babysteps/blog/2018/01/31/an-on-demand-slg-solver-for-chalk/">An on-demand
SLG solver for chalk</a></li>
<li><a href="https://aturon.github.io/blog/2017/04/24/negative-chalk/">Negative Reasoning in Chalk</a> explains the need
for negative reasoning, but not how the SLG solver does it</li>
</ul>
<h1><a class="header" href="#chalk-recursive-solver" id="chalk-recursive-solver">Chalk recursive solver</a></h1>
<p>The recursive solver, as its name suggests, is a logic solver that works
&quot;recursively&quot;. In particular, its basic structure is a function like:</p>
<pre><code class="language-rust ignore">fn(Goal) -&gt; Solution
</code></pre>
<p>where the Goal is some <a href="./canonical_queries.html">canonical goal</a> and
the Solution is a result like:</p>
<ul>
<li>Provable(S): meaning the goal is provable and it is provably exactly (and
only) for the substitution S. S is a set of values for the inference variables
that appear in the goal. So if we had a goal like <code>Vec&lt;?X&gt;: Foo</code>, and we
returned <code>Provable(?X = u32)</code>, it would mean that only <code>Vec&lt;u32&gt;: Foo</code> and not
any other sort of vector (e.g., <code>Vec&lt;u64&gt;: Foo</code> does not hold).</li>
<li>Ambiguous(S): meaning that we can't prove whether or not the goal is true.
This can sometimes come with a substitution S, which offers suggested values
for the inference variables that might make it provable.</li>
<li>Error: the goal cannot be proven.</li>
</ul>
<h2><a class="header" href="#recursion-pros-and-cons" id="recursion-pros-and-cons">Recursion: pros and cons</a></h2>
<p>The recursive solver is so-called because, in the process of solving one goal,
it will &quot;recurse&quot; to solve another. Consider an example like this:</p>
<pre><code class="language-rust ignore">trait A { }
impl&lt;T: A&gt; A for Vec&lt;T&gt; { }
impl A for u32 { }
impl A for i32 { }
</code></pre>
<p>which results in program clauses like:</p>
<pre><code class="language-notrust">forall&lt;T&gt; { Implemented(Vec&lt;T&gt;: A) :- Implemented(T: A) }
Implemented(u32: A)
Implemented(i32: A)
</code></pre>
<p>First, suppose that we have a goal like <code>Implemented(Vec&lt;u64&gt;: A)</code>. This would
proceed like so:</p>
<ul>
<li><code>Solve(Implemented(Vec&lt;u64&gt;: A))</code>
<ul>
<li><code>Solve(Implemented(u64: A))</code>
<ul>
<li>returns <code>Error</code></li>
</ul>
</li>
<li>returns <code>Error</code></li>
</ul>
</li>
</ul>
<p>In other words, the recursive solver would start by applying the first rule,
which would cause us recursively try to solve <code>Implemented(u64: A)</code>. This would
yield an Error result, because there are no applicable rules, and that error
would propagate back up, causing the entire attempt at proving things to fail.</p>
<p>Next, consider <code>Implemented(Vec&lt;u32&gt;: A)</code>. This would proceed like so:</p>
<ul>
<li><code>Solve(Implemented(Vec&lt;u32&gt;: A))</code>
<ul>
<li><code>Solve(Implemented(u32: A))</code>
<ul>
<li>returns <code>Provable</code> with no substitution (no variables)</li>
</ul>
</li>
<li>returns <code>Provable</code></li>
</ul>
</li>
</ul>
<p>Finally, consider <code>Implemented(Vec&lt;?X&gt;: A)</code>. This is more interesting because it
has a variable:</p>
<ul>
<li><code>Solve(Implemented(Vec&lt;?X&gt;: A))</code>
<ul>
<li><code>Solve(Implemented(?X: A))</code>
<ul>
<li>finds two viable solutions, returns <code>Ambiguous</code></li>
</ul>
</li>
<li>returns <code>Ambiguous</code></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#recursion-and-completeness" id="recursion-and-completeness">Recursion and completeness</a></h2>
<p>One side-effect of the recursive solver's structure is that it
cannot solve find solutions in some cases where a traditional
Prolog solver would be successful. Consider this example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait A { }
trait B { }

impl&lt;T: A + B&gt; A for Vec&lt;T&gt; { }

impl A for u32 { }
impl B for u32 { }

impl A for i32 { }
impl B for i8 { }
<span class="boring">}
</span></code></pre></pre>
<p>In the recursive solver, with a goal of <code>Implemented(Vec&lt;?X&gt;: A)</code>, we
recursively try to prove <code>Implemented(?X: A)</code> and <code>Implemented(?X: B)</code>, which
are both ambiguous, and we get stuck there.</p>
<p>The <a href="./engine.html">SLG solver</a> in contrast starts by exploring <code>?X = u32</code> and finds
that it works, and then later tries to explore <code>?X = i32</code> and finds that it
fails (because <code>i32: B</code> is not true).</p>
<h1><a class="header" href="#the-stack-1" id="the-stack-1">The stack</a></h1>
<p>The first &quot;layer&quot; of the recursive solver is the <a href="http://rust-lang.github.io/chalk/chalk_engine/stack/struct.Stack.html"><code>Stack</code></a>. It is really just
what it sounds like: a stack that stores each thing that the recursive solver is
solving. Initially, it contains only one item, the root goal that was given by
the user.</p>
<p>Each frame on the stack has an associated <a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/stack/struct.StackDepth.html"><code>StackDepth</code></a>, which is basically an
index that increases (so 0 is the top of the stack, 1 is the next thing pushed,
etc).</p>
<h2><a class="header" href="#how-the-recursive-solver-works-at-the-highest-level" id="how-the-recursive-solver-works-at-the-highest-level">How the recursive solver works at the highest level</a></h2>
<p>At the highest level, the recursive solver works like so.</p>
<ul>
<li>Push the initial goal <code>G0</code> onto the stack.</li>
<li>Find all the program clauses <code>G1 :- G2...Gn</code> that could apply to the goal <code>G0</code>.</li>
<li>For each program clause, unify <code>G1</code> and <code>G0</code>. If that succeeds, then recursively try to prove each goal <code>Gi</code> in the list <code>G2..Gn</code>:
<ul>
<li>If proving <code>Gi</code> yields an error, return an error.</li>
<li>If proving <code>Gi</code> yields an ambiguity, keep going, but remember that we got an ambiguous result.</li>
<li>If proving <code>Gi</code> succeeded, apply the resulting answer to our inference variables and keep going.</li>
</ul>
</li>
<li>At the end, if any result proved ambiguous, return ambiguous, otherwise construct the final answer and return success.</li>
</ul>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait A { }
trait B { }

impl&lt;T: B&gt; A for Vec&lt;T&gt; { }

impl B for u32 { }
<span class="boring">}
</span></code></pre></pre>
<p>Imagine we are trying to prove <code>Implemented(Vec&lt;?X&gt;: A)</code>. There is one unbound
inference variable here, <code>?X</code>. We will ultimately get the result <code>Provable(?X = u32)</code>. But how do we find it?</p>
<ul>
<li>Initially we are solving <code>Implemented(Vec&lt;?X&gt;: A)</code>
<ul>
<li>we find one applicable program clause, <code>forall&lt;T&gt; { Implemented(Vec&lt;T&gt;: A) :- Implemented(T: B) }</code>.</li>
<li>after unification, the list of subgoals is <code>[Implemented(?X: B)]</code>.</li>
<li>we recursively try to solve <code>Implemented(?X: B)</code>
<ul>
<li>we find one applicable program clause, <code>Implemented(u32: B)</code>.</li>
<li>after unification, <code>?X = u32</code>, but there are no more subgoals.</li>
<li>we return the answer <code>Provable(?X = u32)</code>.</li>
</ul>
</li>
<li>we apply the substitution <code>?X = u32</code>, and find there are no more subgoals.</li>
<li>we return the answer <code>Provable(?X = u32)</code>.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#why-do-we-need-the-stack" id="why-do-we-need-the-stack">Why do we need the stack?</a></h2>
<p>You may have noticed that the description above never seemed to use the <a href="http://rust-lang.github.io/chalk/chalk_engine/stack/struct.Stack.html"><code>Stack</code></a>,
it only relied on the program stack. That's because I left out any discussion
of cycles. In fact, the <a href="http://rust-lang.github.io/chalk/chalk_engine/stack/struct.Stack.html"><code>Stack</code></a> data structure does mirror the program stack,
it just adds some extra information we use in resolving cycles. We'll discuss
cycles in the next chapter, when we discuss the <a href="recursive/./search_graph.html">search graph</a>.</p>
<h2><a class="header" href="#figuring-out-if-something-is-on-the-stack" id="figuring-out-if-something-is-on-the-stack">Figuring out if something is on the stack</a></h2>
<p>The stack itself never stores the goal associated with a particular entry. That
information is found in the <a href="recursive/./search_graph.html">search graph</a>, which will be covered in detail in
the next section. For now it suffices to say that the search graph maps from
&quot;some goal that we are currently solving&quot; to &quot;information about that goal&quot;, and
one of the bits of information is the <a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/stack/struct.StackDepth.html"><code>StackDepth</code></a> of its entry on the stack
(if any).</p>
<p>Therefore, when we are about to start solving some (canonical) goal G, we can
detect a cycle by checking in the <a href="recursive/./search_graph.html">search graph</a> to see whether G has an associated
<a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/stack/struct.StackDepth.html"><code>StackDepth</code></a>. If so, it must be on the stack already (and we can set the
<a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/stack/struct.StackEntry.html#structfield.cycle"><code>cycle</code></a> field to true...but I get ahead of myself, read the next chapters
to learn more about that).</p>
<h1><a class="header" href="#inductive-cycles" id="inductive-cycles">Inductive cycles</a></h1>
<p>Recursive solving without cycles is easy. Solving with cycles is rather more
complicated. Before we get into the details of the implementation,
let's talk a bit about what behavior we actually <em>expect</em> in the face
of possible cycles.</p>
<h2><a class="header" href="#inductive-cycles-1" id="inductive-cycles-1">Inductive cycles</a></h2>
<p>By default, Rust trait solving is <strong>inductive</strong>. What that means is that, roughly
speaking, you have to prove something is true without any cycles (i.e., you
can't say &quot;it's true because it's true&quot;!).</p>
<p>For our purpose, a &quot;cycle&quot; means that, in the course of proving some canonical
goal G, we had to prove that same goal G again.</p>
<p>Consider this Rust program:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait A { }
impl&lt;T: A&gt; A for Vec&lt;T&gt; { }
impl A for u32 { }
<span class="boring">}
</span></code></pre></pre>
<p>Whether or not we hit a cycle will depend on the goal we are trying
to solve. If for example we are trying to prove <code>Implemented(Vec&lt;u32&gt;: A)</code>,
then we don't hit any cycle:</p>
<ul>
<li><code>Implemented(Vec&lt;u32&gt;: A) :- Implemented(u32: A)</code> // from the first impl
<ul>
<li><code>Implemented(u32: A)</code> // from the second impl</li>
</ul>
</li>
</ul>
<p>But what if we are trying to prove <code>Implemented(?X: A)</code>? This is a bit
more interesting. Because we don't know what <code>?X</code> is, both impls are
actually potentially applicable, so we wind up with two ways to
prove our goal. We will try them out one after the other.</p>
<p>One possible execution might be:</p>
<ul>
<li>Prove <code>Implemented(?X: A)</code>
<ul>
<li>we find the program clause <code>forall&lt;T&gt; { Implemented(Vec&lt;T&gt;: A) :- Implemented(T: A) }</code> from the first impl
<ul>
<li>we create the variable <code>?Y</code> to represent <code>T</code> and unify <code>?X = Vec&lt;?Y&gt;</code>.</li>
<li>after unification, we have the subgoal <code>Implemented(?Y: A)</code>
<ul>
<li>when we go to recursively prove this impl, however, we find that it is already on the stack</li>
<li>this is because the <a href="recursive/../canonical_queries.html">canonical form</a> of <code>Implemented(?X: A)</code> and <code>Implemented(?Y: A)</code> is the same</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#what-happens-if-we-treat-inductive-cycles-as-errors" id="what-happens-if-we-treat-inductive-cycles-as-errors">What happens if we treat inductive cycles as errors?</a></h2>
<p>So, what do we do when we hit an inductive cycle? Given that we told you that an
inductive proof cannot contain cycles, you might imagine that we can just treat
such a cycle as an error. But this won't give us the correct result.</p>
<p>Consider our previous example. If we just treat that cycle as an error, then we
will conclude that the impl for <code>Vec&lt;T&gt;</code> doesn't apply to <code>?X: A</code>, and we'll
proceed to try the impl for <code>u32</code>. This will let us reason that <code>?X: A</code> is
provable if <code>?X = u32</code>. This is, in fact, correct: <code>?X = u32</code> <em>is</em> a possible
answer. The problem is, it's not the only one!</p>
<p>In fact, <code>Implemented(?X: A)</code> has an <strong>infinite</strong> number of answers. It is true
for <code>?X = u32</code>. It is true for <code>?X = Vec&lt;u32&gt;</code>. It is also true for
<code>Vec&lt;Vec&lt;u32&gt;&gt;</code> and <code>Vec&lt;Vec&lt;Vec&lt;u32&gt;&gt;&gt;</code> and so on.</p>
<p>Given this, the correct result for our query is actually &quot;ambiguous&quot; -- in
particular, there is no unique substitution that we can give that would make the
query provable.</p>
<h2><a class="header" href="#how-we-solve-cycles-loop-and-try-again" id="how-we-solve-cycles-loop-and-try-again">How we solve cycles: loop and try again</a></h2>
<p>The way we actually handle cycles is by iterating until we reach a fixed point
(or ambiguity). We start out by assuming that all cycles are errors and we try
to find some solution S. If we succeed, then we can do a loop and iterate again
-- this time, for each cycle, we assume the result is S. This may yield some new
solution, S1. The key point here is that we now have <strong>two possible solutions</strong>
to the same goal, S and S1. This implies two possibilities:</p>
<ul>
<li>If S == S1, then in fact there is a unique solution, so we can return <code>Provable(S)</code>.</li>
<li>If S != S1, then we know there are two solutions, which means that there is
not one unique solution, and hence the correct result is <strong>ambiguous</strong>,
and in fact we can just stop and return right now.</li>
</ul>
<p>This technique is very similar to the traditional Prolog technique of handling
cycles, which is called <strong>tabling</strong>. The difference between our approach and
tabling is that we are always looking for a unique solution, whereas Prolog
(like the <a href="recursive/../engine.html">SLG solver</a>) tries to enumerate all solutions (i.e., in Prolog,
solving a goal is not a function but an iterator that yields solutions, and
hence it would yield up S first, and then S1, and then any further answers we
might get).</p>
<p>Intuitively, what is happening here is that we're building bigger and bigger
&quot;proof trees&quot; (i.e., trees of impl applications). In the first iteration, where
we assumed that all recursive calls were errors, we would find exactly one
solution, <code>u32: A</code> -- this is the root tree. In the next iteration, we can use
this result to build a tree for <code>Vec&lt;u32&gt;: A</code> and so forth.</p>
<h2><a class="header" href="#inductive-cycles-with-no-base-case" id="inductive-cycles-with-no-base-case">Inductive cycles with no base case</a></h2>
<p>It is interesting to look at what happens without the base case. Consider this
program:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait B { }
impl&lt;T: B&gt; B for Vec&lt;T&gt; { }
<span class="boring">}
</span></code></pre></pre>
<p>In this case, there is no base case -- this means that in fact there are no
solutions at all to the query <code>?X: B</code>. The reason is that the only type that
could match would be a type of infinite size like <code>Vec&lt;Vec&lt;Vec&lt;...&gt;&gt;&gt;: B</code>, where
the chain of <code>Vec</code> never terminates.</p>
<p>In our solver, this will work out just fine. We will wind up recursing
and encountering a cycle. This will be treated as an error in the first
iteration -- and then, at the end, we'll still have an error. This means
that we've reached a fixed point, and we can stop.</p>
<h2><a class="header" href="#inductive-cycles-when-do-we-ever-terminate" id="inductive-cycles-when-do-we-ever-terminate">Inductive cycles: when do we ever terminate</a></h2>
<p>You might be wondering whether there are any examples of inductive cycles that
actually terminate successfully and without ambiguity. In fact, there are very
few, but you can construct an example like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait C { }
impl&lt;T: C + D&gt; C for Vec&lt;T&gt; { }
impl C for u32 { }

trait D { }
<span class="boring">}
</span></code></pre></pre>
<p>In this case, the only valid result of <code>Implemented(?X: C)</code> is <code>?X = u32</code>. It can't
be <code>Vec&lt;u32&gt;</code> because <code>Implemented(u32: D)</code> is not true.</p>
<p>How does this work out with the recursive solver? In the first iteration,
we wind up with <code>?X = u32</code>, but we do encounter a cycle:</p>
<ul>
<li>proving <code>Implemented(?X: C)</code> has two possibilities...
<ul>
<li><code>?X = Vec&lt;?Y&gt;</code> and <code>Implemented(?Y: C)</code>, which is a cycle (error, at least in this iteration)</li>
<li><code>?X = u32</code>, succeeds</li>
</ul>
</li>
</ul>
<p>So then we try the next iteration:</p>
<ul>
<li>proving <code>Implemented(?X: C)</code> has two possibilities...
<ul>
<li><code>?X = Vec&lt;?Y&gt;</code> and <code>Implemented(?Y: C)</code>, which is a cycle, so we use our previous result of <code>?Y = u32</code>
<ul>
<li>we then have to prove <code>Implemented(u32: D)</code>, which fails</li>
</ul>
</li>
<li><code>?X = u32</code>, succeeds</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#the-search-graph-and-caching" id="the-search-graph-and-caching">The search graph and caching</a></h1>
<p>So now we have a good idea of <a href="recursive/./inductive_cycles.html">what behavior we expect from cycles</a>, or
at least inductive cycles (we'll talk about <a href="recursive/./coinduction.html">coinduction</a> later). But how do we
actually implement this? That's where the <a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/search_graph/struct.SearchGraph.html"><code>SearchGraph</code></a> comes into play.</p>
<p>The role of the <a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/search_graph/struct.SearchGraph.html"><code>SearchGraph</code></a> is to store information about each goal that we
are currently solving. Typically, these are goals on the stack -- but other
times, they are goals that are no longer on the stack, but whose results
(because of a cycle) were dependent on something that is still on the stack.
We'll work through some examples to make it all clear.</p>
<h2><a class="header" href="#structure-of-the-search-graph" id="structure-of-the-search-graph">Structure of the search graph</a></h2>
<p>The search graph consists of nodes, each of which is assigned an index called a
<a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/search_graph/struct.DepthFirstNumber.html"><code>DepthFirstNumber</code></a>. The name of this index alludes to the fact that, as we try
to prove a given goal, we are implicitly performing a &quot;depth-first search&quot; over
a graph of subgoals, and the index in the search graph is similar to a pre-order
index on the resulting tree.</p>
<h3><a class="header" href="#example-search-graph" id="example-search-graph">Example search graph</a></h3>
<p>Consider this example trait plus impls:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait A { }
impl&lt;T: A, U: A&gt; A for Result&lt;T, U&gt; { }
impl A for u32 { }
impl A for i32 { }
impl A for f32 { }
<span class="boring">}
</span></code></pre></pre>
<p>If we consider the full set of goals/subgoals that are involved in proving <code>Implemented(Result&lt;u32, i32&gt;: A)</code>, 
it would look like this:</p>
<pre class="mermaid">graph TD
  G1["Implemented(Result&lt;u32, i32&gt;: A)<br>Pre-order number: 0<br>DepthFirstNumber: 0"]
  G2["Implemented(u32: A)<br>Pre-order number: 1<br>DepthFirstNumber: 1"]
  G3["Implemented(i32: A)<br>Pre-order number: 2<br>DepthFirstNumber: 1"]
  G1 --> G2
  G1 --> G3
</pre>
<p>The graph also shows a possible set of pre-order numbers, as well as the
<a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/search_graph/struct.DepthFirstNumber.html"><code>DepthFirstNumber</code></a> that would be used in the search graph. You can see that
they start to diverge. Pre-order numbers uniquely identify each goal in the
graph. In contrast, after we finish proving <code>Implemented(u32: A)</code>, we remove
that node the graph, and hence its <a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/search_graph/struct.DepthFirstNumber.html"><code>DepthFirstNumber</code></a> is re-used.</p>
<h2><a class="header" href="#goal-lifecycle" id="goal-lifecycle">Goal lifecycle</a></h2>
<p>Every goal that we prove in the recursive solver goes through the following states:</p>
<pre class="mermaid">graph TD
  NewlyCreated["Newly created"]
  OnStack["On stack and in the search graph"]
  InGraph["Popped from stack but retained in search graph"]
  ProcessingComplete["Processing complete"]
  InCache["Stored in the cache"]
  NewlyCreated --> OnStack
  OnStack -- Explore all program clauses for the goal --> ProcessingComplete
  ProcessingComplete -- If node is a participant in a cycle --> InGraph
  InGraph -- On next iteration --> OnStack
  ProcessingComplete -- If not part of a cycle or when fixed-point is reached --> InCache
</pre>
<p>At first, we create the goal and push it onto the stack, and we also add it to
the search graph. We then explore each of the relevant program clauses to try and
find the solution(s) to the goal. Along the way we update the overall solution:</p>
<ul>
<li>If there are no valid solutions, then the result is an error.</li>
<li>If there is exactly one solution, then we remember it as the unique solution.</li>
<li>If there are multiple distinct solutions, the result is &quot;ambiguous&quot;.</li>
</ul>
<p>While we are doing this solving, we also track what other goals this goal winds
up depending on. In particular, we are looking to see whether it winds up as a
participant in a cycle -- that is, if it depends on any goals further up the
goal stack.</p>
<p>If, when we're done with all program clauses, the goal never participated in any
cycles, then we have reached our final solution. We can take that result and put
it into the cache. The next time we look for a solution to this goal, we'll
check that cache and return the result.</p>
<p>But otherwise, if the goal <em>was</em> a participant in a cycle, then we have to
iterate, as described in the <a href="recursive/./inductive_cycles.html">section on cycles</a>. In that
case, we keep the goal in the search graph, but we remove it from the stack.
This allows the search graph to serve as a kind of &quot;interim cache&quot;. If, as we
continue to search through the other nodes that remain on the stack, we have to
solve this same goal again, we will find it in the search cache and re-use the
result.</p>
<p>For goals that are participants in a cycle, when the cycle reaches its
fixed-point (i.e., the top-most node has stopped changing), we go through and
take all the results for all the subgoals (which are still present in the search
graph) and move them all into the &quot;final cache&quot;.</p>
<p>In other words, any result that is present in the <em>search graph</em> can be
considered an &quot;interim cache&quot;, with a result that is still being determined and
may be dependent on other goals on the stack. Once the goal is completely
processed, it is moved to the cache field where others can use it.</p>
<h2><a class="header" href="#processing-a-single-goal-a-flow-chart" id="processing-a-single-goal-a-flow-chart">Processing a single goal, a flow chart</a></h2>
<p>Whenever we are asked to solve a goal, these are the steps we take:</p>
<pre class="mermaid">graph TD
  GoalInGraph["Goal in search graph?"]
  FlagAsHead["If goal is on stack,<br>flag as head of cycle."]
  ReturnCurrentResult["Return result from<br>search graph."]
  PushOnStack["Push goal on stack,<br>add to the search graph with index `G`,<br>initial result is error"]
  ProcessEachClause["Process each program clause in turn,<br>computing result,<br>and tracking `Minimums`"]
  IsCycleParticipant["Is G dependent on<br>goal lower in stack?"]
  StoreInCache["Move results `G..` <br>from search graph to cache"]
  PopFromCacheNotGraph["Pop goal from stack<br>but leave in search graph"]
  CompareResult["Did result change from<br>what is stored in search graph?"]
  UpdateSearchGraph["Update stored result<br>in search graph"]
  ClearPreviousIteration["Clear search graph nodes `G+1..`<br>from previous iteration"]

  GoalInGraph -- Yes --> FlagAsHead
  FlagAsHead --> ReturnCurrentResult
  GoalInGraph -- No, not in the graph --> PushOnStack
  PushOnStack --> ProcessEachClause
  ProcessEachClause -- Is head of cycle --> CompareResult
  ProcessEachClause -- Not head of cycle --> IsCycleParticipant
  CompareResult -- No, fixed-point reached --> IsCycleParticipant
  CompareResult -- Yes, result changed --> UpdateSearchGraph
  UpdateSearchGraph --> ClearPreviousIteration
  ClearPreviousIteration --> ProcessEachClause
  IsCycleParticipant -- No --> StoreInCache
  IsCycleParticipant -- Yes --> PopFromCacheNotGraph
</pre>
<h2><a class="header" href="#starting-to-prove-a-goal" id="starting-to-prove-a-goal">Starting to prove a goal</a></h2>
<p>The first thing we do when proving some goal G is to check the search graph to
see if there is already a node for this goal.</p>
<h3><a class="header" href="#if-there-is-a-node-for-g" id="if-there-is-a-node-for-g">If there is a node for G</a></h3>
<p>If there is a node for G, that indicates that there is some sort of cycle
involved in the graph. For now, we will defer this case, and come back to it
after we've explained what happens without cycles.</p>
<h3><a class="header" href="#if-there-is-no-node-for-g-pushing-a-new-goal-onto-the-stack" id="if-there-is-no-node-for-g-pushing-a-new-goal-onto-the-stack">If there is no node for G: pushing a new goal onto the stack</a></h3>
<p>If there is no node for G in the graph, then we have a new subgoal to add
to the graph. We will first push a new entry onto the <a href="recursive/./stack.html">stack</a>, yielding some new
stack depth <code>d</code>. Then we create a new <a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/search_graph/struct.Node.html"><code>Node</code></a> in the search graph. It will be
assigned the next available <a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/search_graph/struct.DepthFirstNumber.html"><code>DepthFirstNumber</code></a>. The search graph node contains a field
<a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/search_graph/struct.Node.html#structfield.stack_depth"><code>stack_depth</code></a> that will be set to <code>Some(d)</code>, where <code>d</code> is the depth of the
node on the stack.</p>
<p>The search graph node also stores the &quot;current solution&quot; for the given goal. As
described in the search on <a href="recursive/./inductive_cycles.html">inductive cycles</a>, this solution starts out
as an error but may be gradually widened as we iterate, if we find solutions.</p>
<h2><a class="header" href="#tracking-dependencies" id="tracking-dependencies">Tracking dependencies</a></h2>
<p>The way that we track dependencies is through a structure called the
<a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/lib/struct.Minimums.html"><code>Minimums</code></a>. The name comes from the idea that it is tracking the minimum
<a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/search_graph/struct.DepthFirstNumber.html"><code>DepthFirstNumber</code></a> of any goal whose result we depended on. The minimum for a
goal G1 starts out as G1, since its result depends on itself, but if it winds up
recursively processing some goal G2 that is on the stack, then the minimum will
be adjusted to G2.</p>
<p>Along with the interim solution, the search graph node for a given goal also
stores the <a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/lib/struct.Minimums.html"><code>Minimums</code></a> that resulted from computing that interim solution
(i.e., what goals did that solution depend on). If some goal G1 winds up
recursively invoking some goal G2 that is in the search graph but <em>not</em> present
on the stack, then we update the current <a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/lib/struct.Minimums.html"><code>Minimums</code></a> with the values stored in
the search graph.</p>
<h2><a class="header" href="#removing-nodes-from-the-graph" id="removing-nodes-from-the-graph">Removing nodes from the graph</a></h2>
<p>Once we complete the processing for a node, it needs to be removed from the
processing stack. But we wish to leave it in the graph if it is dependent on
something else that is already on the stack. We do that just by checking the
<a href="http://rust-lang.github.io/chalk/chalk_solve/recursive/lib/struct.Minimums.html"><code>Minimums</code></a> value to see if it is less than the current goal.</p>
<h1><a class="header" href="#coinduction-1" id="coinduction-1">Coinduction</a></h1>
<p>TBD</p>
<h1><a class="header" href="#glossary-and-terminology" id="glossary-and-terminology">Glossary and terminology</a></h1>
<p>This is a glossary of terminology (possibly) used in the chalk crate.</p>
<h2><a class="header" href="#binary-connective" id="binary-connective">Binary connective</a></h2>
<p>There are sixteen logical connectives on two boolean variables. The most
interesting in this context are listed below. There is also a truth table given
which encodes the possible results of the operations like this</p>
<pre><code class="language-notrust">f(false, false) f(false, true) f(true, false) f(true, true).
</code></pre>
<p>As a shorthand the resulting truth table is encoded with <code>true = 1</code> and <code>false = 0</code>.</p>
<table><thead><tr><th>Truth table</th><th>Operator symbol</th><th>Common name</th></tr></thead><tbody>
<tr><td>0001</td><td>&amp;&amp;</td><td>Conjunction; and</td></tr>
<tr><td>1001</td><td>&lt;=&gt;</td><td>Equivalence; if and only if; iff</td></tr>
<tr><td>1101</td><td>=&gt;</td><td>Implication; if ... then</td></tr>
</tbody></table>
<h2><a class="header" href="#binder" id="binder">Binder</a></h2>
<p>A binder is an expression that binds a literal to a certain expression.
Examples for binders:</p>
<ul>
<li>The universal quantifier <code>forall(a)</code> states that a certain condition holds for
all allowed values for <code>a</code>.</li>
<li>A function definition <code>f(x) = a * x</code> is a binder for the variable <code>x</code> whereas
<code>a</code> is a free variable.</li>
<li>A sum <code>\sum_n x_n</code> binds the index variable <code>n</code>.</li>
</ul>
<h2><a class="header" href="#canonical-form" id="canonical-form">Canonical Form</a></h2>
<p>A formula in canonical form has the property that its DeBruijn indices are
minimized. For example when the formula <code>forall&lt;0, 1&gt; { 0: A &amp;&amp; 1: B }</code> is
processed, both &quot;branches&quot; <code>0: A</code> and <code>1: B</code> are processed individually. The
first branch would be in canonical form, the second branch not since the
occurring DeBruijn index <code>1</code> could be replaced with <code>0</code>.</p>
<h2><a class="header" href="#clause" id="clause">Clause</a></h2>
<p>A clause is the disjunction of several expressions. For example the clause
<code>condition_1 || condition_2 || ...</code> states that at least one of the conditions
holds.</p>
<p>There are two notable special cases of clauses. A <em>Horn clause</em> has at most one
positive literal. A <em>Definite clause</em> has exactly one positive literal.</p>
<p><em>Horn clauses</em> can be written in the form <code>A || !B || !C || ...</code> with <code>A</code> being
the optional positive literal. Due to the equivalence <code>(P =&gt; Q) &lt;=&gt; (!P || Q)</code>
the clause can be expressed as <code>B &amp;&amp; C &amp;&amp; ... =&gt; A</code> which means that A is true
if <code>B</code>, <code>C</code>, etc. are all true. All rules in chalk are in this form. For example</p>
<pre><code class="language-notrust">struct A&lt;T&gt; {}
impl&lt;T&gt; B for A&lt;T&gt; where T: C + D {}
</code></pre>
<p>is expressed as the <em>Horn clause</em> <code>(T: C) &amp;&amp; (T: D) =&gt; (A&lt;T&gt;: B)</code>. This formula
has to hold for all values of <code>T</code>. The second example</p>
<pre><code class="language-notrust">struct A {}
impl B for A {}
impl C for A {}
</code></pre>
<p>is expressed as the <em>Horn clause</em> <code>(A: B) &amp;&amp; (A: C)</code>. Note the missing
consequence.</p>
<h2><a class="header" href="#debruijn-index" id="debruijn-index">DeBruijn Index</a></h2>
<p>DeBruijn indices numerate literals that are bound in an unambiguous way. The
literal is given the number of its binder. The indices start at zero from the
innermost binder increasing from the inside out.</p>
<p>Given the example <code>forall&lt;T&gt; { exists&lt;U&gt; { T: Foo&lt;Item=U&gt; } }</code> the
literal names <code>U</code> and <code>T</code> are replaced with <code>0</code> and <code>1</code> respectively and the names are erased from the binders: <code>forall&lt;_&gt; { exists&lt;_&gt; { 1: Foo&lt;Item=0&gt; } }</code>.</p>
<h2><a class="header" href="#formula" id="formula">Formula</a></h2>
<p>A formula is a logical expression consisting of literals and constants connected
by logical operators.</p>
<h2><a class="header" href="#goal" id="goal">Goal</a></h2>
<p>With a set of type variables, given types, traits and impls, a goal specifies a
problem which is solved by finding types for the type variables that satisfy the
formula. For example the goal <code>exists&lt;T&gt; { T: u32 }</code> can be solved with <code>T = u32</code>.</p>
<h2><a class="header" href="#literal" id="literal">Literal</a></h2>
<p>A literal is an atomic element of a formula together with the constants <code>true</code>
and <code>false</code>. It is equivalent to a variable in an algebraic expressions. Note
that literals are <em>not</em> the same as the type variables used in specifying a
goal.</p>
<h2><a class="header" href="#normal-form" id="normal-form">Normal form</a></h2>
<p>To say that a statement is in a certain <em>normal form</em> means that the pattern in
which the subformulas are arranged fulfil certain rules. The individual patterns
have different advantages for their manipulation.</p>
<h3><a class="header" href="#conjunctive-normal-form-cnf" id="conjunctive-normal-form-cnf">Conjunctive normal form (CNF)</a></h3>
<p>A formula in CNF is a conjunction of disjunctions. For example <code>(x1 || x2 || x3) &amp;&amp; (x4 || x5 || x6)</code> is in CNF.</p>
<h3><a class="header" href="#disjunctive-normal-form-dnf" id="disjunctive-normal-form-dnf">Disjunctive normal form (DNF)</a></h3>
<p>A formula in DNF is a disjunction of conjunctions. For example <code>(x1 &amp;&amp; x2 &amp;&amp; x3) || (x4 &amp;&amp; x5 &amp;&amp; x6)</code> is in DNF.</p>
<h3><a class="header" href="#negation-normal-form-nnf" id="negation-normal-form-nnf">Negation normal form (NNF)</a></h3>
<p>A formula in NNF consists only of literals, the connectives <code>&amp;&amp;</code> and <code>||</code> and
<code>true</code> and <code>false</code>.</p>
<h3><a class="header" href="#prenex-normal-form-pnf" id="prenex-normal-form-pnf">Prenex normal form (PNF)</a></h3>
<p>All quantifiers are on the highest level of a formula and do not occur inside
the subformulas of the expression.</p>
<ul>
<li><code>forall(x). exists(y). forall(z). P(x) &amp;&amp; P(y) =&gt; P(z)</code> is in PNF.</li>
<li><code>(exists(x). P(x)) =&gt; exists(y). P(y) &amp;&amp; forall(z). P(z)</code> is <em>not</em> in PNF.</li>
</ul>
<h2><a class="header" href="#normalization" id="normalization">Normalization</a></h2>
<p>Normalization is the process of converting an associated type to a concrete
type. In the case of an iterator this would mean that the associated <code>Item</code> type
is replaced with something more meaningful with respect to the individual
context (e.g. <code>u32</code>).</p>
<h2><a class="header" href="#projection" id="projection">Projection</a></h2>
<p>Projection is the reference to a field or (in the context of Rust) to a type
from another type.</p>
<h2><a class="header" href="#satisfiability" id="satisfiability">Satisfiability</a></h2>
<p>A formula is satisfiable iff there is a valuation for the atoms inside the
formula that makes it true.</p>
<h2><a class="header" href="#unification" id="unification">Unification</a></h2>
<p>Unification is the process of solving a formula. That means unification finds
values for all the free literals of the formula that satisfy it. In the context
of chalk the values refer to types.</p>
<h2><a class="header" href="#universe" id="universe">Universe</a></h2>
<p>A universe sets the scope in which a particular variable name is bound. (See
<em>Binder</em>.) A universe can encapsulate other universes. A universe can
be contained by only one parent universe. Universes have therefore a tree-like
structure. A universe can access the variable names of itself and the parent
universes but not of the sibling universes.</p>
<h2><a class="header" href="#well-formed" id="well-formed">Well-formed</a></h2>
<p>A formula is well-formed if it is constructed according to a predefined set of
syntactic rules.</p>
<p>In the context of the Rust type system this means that basic rules for type
construction have to be met. Two examples: 1) Given a struct definition</p>
<pre><code class="language-notrust">struct HashSet&lt;T: Hash&gt;
</code></pre>
<p>then a type <code>HashSet&lt;i32&gt;</code> is well-formed since <code>i32</code> implements <code>Hash</code>. A type
<code>HashSet&lt;NoHash&gt;</code> with a type <code>NoHash</code> that does not implement the <code>Hash</code> trait
is not well-formed.</p>
<ol start="2">
<li>If a trait demands by its definition the implementation of further traits
for a certain type then these secondary traits have to be implemented as well.
If a type <code>Foo</code> implements <code>trait Eq: PartialEq</code> then this type has to implement
<code>trait PartialEq</code> as well. If it does not, then the type <code>Foo: Eq</code> is not well
formed according to Rust type building rules.</li>
</ol>
<h2><a class="header" href="#quantifier" id="quantifier">Quantifier</a></h2>
<h3><a class="header" href="#existential-quantifier" id="existential-quantifier">Existential quantifier</a></h3>
<p>A formula with the existential quantifier <code>exists(x). P(x)</code> is satisfiable if
and only if there exists at least one value for all possible values of x which
satisfies the subformula <code>P(x)</code>.</p>
<p>In the context of chalk, the existential quantifier usually demands the
existence of exactly one instance (i.e. type) that satisfies the formula (i.e.
type constraints). More than one instance means that the result is ambiguous.</p>
<h3><a class="header" href="#universal-quantifier" id="universal-quantifier">Universal quantifier</a></h3>
<p>A formula with the universal quantifier <code>forall(x). P(x)</code> is satisfiable
if and only if the subformula <code>P(x)</code> is true for all possible values for x.</p>
<h3><a class="header" href="#helpful-equivalences" id="helpful-equivalences">Helpful equivalences</a></h3>
<ul>
<li><code>not(forall(x). P(x)) &lt;=&gt; exists(x). not(P(x))</code></li>
<li><code>not(exists(x). P(x)) &lt;=&gt; forall(x). not(P(x))</code></li>
</ul>
<h2><a class="header" href="#skolemization" id="skolemization">Skolemization</a></h2>
<p>Skolemization is a technique of transferring a logical formula with existential
quantifiers to a statement without them. The resulting statement is in general
not equivalent to the original statement but equisatisfiable.</p>
<h2><a class="header" href="#validity" id="validity">Validity</a></h2>
<p>An argument (<em>premise</em> therefore <em>conclusion</em>) is valid iff there is no
valuation which makes the premise true and the conclusion false.</p>
<p>Valid: <code>A &amp;&amp; B therefore A || B</code>. Invalid: <code>A || B therefore A &amp;&amp; B</code> because the
valuation <code>A = true, B = false</code> makes the premise true and the conclusion false.</p>
<h2><a class="header" href="#valuation" id="valuation">Valuation</a></h2>
<p>A valuation is an assignment of values to all variables inside a logical
formula.</p>
<h1><a class="header" href="#bibliography" id="bibliography">Bibliography</a></h1>
<p>If you'd like to read more background material, here are some
recommended texts and papers:</p>
<h2><a class="header" href="#blog-posts" id="blog-posts">Blog Posts</a></h2>
<ul>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/">Lowering Rust traits to logic</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/">Unification in Chalk, part 1</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/04/23/unification-in-chalk-part-2/">Unification in Chalk, part 2</a></li>
<li><a href="https://aturon.github.io/blog/2017/04/24/negative-chalk/">Negative reasoning in Chalk</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/05/25/query-structure-in-chalk/">Query structure in chalk</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/09/12/tabling-handling-cyclic-queries-in-chalk/">Cyclic queries in chalk</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2018/01/31/an-on-demand-slg-solver-for-chalk/">An on-demand SLG solver for chalk</a></li>
</ul>
<h2><a class="header" href="#papers" id="papers">Papers</a></h2>
<p><a name="pphhf"></a></p>
<p><a href="https://dl.acm.org/citation.cfm?id=868380">&quot;A proof procedure for the logic of Hereditary Harrop formulas&quot;</a>,
by Gopalan Nadathur. This paper covers the basics of universes,
environments, and Lambda Prolog-style proof search. Quite readable.</p>
<p><a name="slg"></a> </p>
<p><a href="https://dl.acm.org/citation.cfm?id=651202">&quot;A new formulation of tabled resolution with delay&quot;</a>, by
Theresa Swift. This paper gives a kind of abstract treatment of the
SLG formulation that is the basis for our on-demand solver.</p>
<h2><a class="header" href="#books" id="books">Books</a></h2>
<ul>
<li>&quot;Introduction to Formal Logic&quot;, Peter Smith</li>
<li>&quot;Handbook of Practical Logic and Automated Reasoning&quot;, John Harrison</li>
<li>&quot;Types and Programming Languages&quot;, Benjamin C. Pierce</li>
<li><a href="https://www.amazon.com/Programming-Higher-Order-Logic-Dale-Miller/dp/052187940X">Programming with Higher-order Logic</a>, by Dale Miller and Gopalan
Nadathur, covers the key concepts of Lambda prolog. Although it's a
slim little volume, it's the kind of book where you learn something
new every time you open it.</li>
</ul>
<h2><a class="header" href="#incomplete-chapters" id="incomplete-chapters">Incomplete chapters</a></h2>
<p>Some topics yet to be written:</p>
<ul>
<li>Elaborate on the proof procedure</li>
<li>SLG solving – introduce negative reasoning</li>
</ul>
<h1><a class="header" href="#publishing-chalk" id="publishing-chalk">Publishing Chalk</a></h1>
<p><strong>Note: this is mostly only useful for maintainers</strong></p>
<p>The following crates get published to crates.io:</p>
<ul>
<li><code>chalk-derive</code></li>
<li><code>chalk-engine</code></li>
<li><code>chalk-ir</code></li>
<li><code>chalk-solve</code></li>
</ul>
<p>The following crates get versioned without publishing:</p>
<ul>
<li><code>chalk-parse</code></li>
<li><code>chalk-integration</code></li>
<li><code>chalk</code> (root directory)</li>
</ul>
<h2><a class="header" href="#pre-publish" id="pre-publish">Pre-publish</a></h2>
<ul>
<li>Remove the <code>-dev</code> suffix from the versions in each <code>cargo.toml</code></li>
<li>Bump the dependency version for each crate</li>
<li>Change the <code>Unreleased</code> section in <code>RELEASES.md</code> to the version getting published</li>
<li>Create commit</li>
</ul>
<h2><a class="header" href="#publishing" id="publishing">Publishing</a></h2>
<ul>
<li>For each crate in the order above, run <code>cargo publish</code>
<ul>
<li>You will probably have to wait a couple seconds between each to let the index update</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#post-publish" id="post-publish">Post-publish</a></h2>
<ul>
<li>Bump the minor version in each <code>cargo.toml</code> and add a <code>-dev</code> suffix</li>
<li>Bump the dependency version for each crate</li>
<li>Add an <code>Unreleased</code> section in the <code>RELEASES.md</code></li>
<li>Run <code>cargo check</code></li>
<li>Tag release commit on github (e.g. <code>v0.10.0</code>)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
