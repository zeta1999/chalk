initSidebarItems({"enum":[["ClosureKind",""],["Const",""],["DomainGoal",""],["FloatTy",""],["GenericArg",""],["Goal",""],["ImplType",""],["InlineBound","An inline bound, e.g. `: Foo<K>` in `impl<K, T: Foo<K>> SomeType<T>`."],["IntTy",""],["Item",""],["Kind",""],["LeafGoal",""],["Lifetime",""],["Mutability",""],["Polarity",""],["ScalarType",""],["Ty",""],["UintTy",""],["VariableKind",""],["WellKnownTrait",""],["WhereClause",""]],"struct":[["AliasEqBound","Represents an alias equality bound on e.g. a type or type parameter. Does not know anything about what it's binding."],["AssocTyDefn",""],["AssocTyValue",""],["Clause","This allows users to add arbitrary `A :- B` clauses into the logic; it has no equivalent in Rust, but it's useful for testing."],["ClosureDefn",""],["Field",""],["FnAbi",""],["FnDefn",""],["Identifier",""],["Impl",""],["OpaqueTyDefn",""],["Program",""],["ProjectionTy",""],["QuantifiedInlineBound",""],["QuantifiedWhereClause",""],["Span",""],["StructDefn",""],["StructFlags",""],["StructRepr",""],["TraitBound","Represents a trait bound on e.g. a type or type parameter. Does not know anything about what it's binding."],["TraitDefn",""],["TraitFlags",""],["TraitRef",""]]});