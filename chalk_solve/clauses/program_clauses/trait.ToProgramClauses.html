<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `ToProgramClauses` trait in crate `chalk_solve`."><meta name="keywords" content="rust, rustlang, rust-lang, ToProgramClauses"><title>chalk_solve::clauses::program_clauses::ToProgramClauses - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script src="../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="shortcut icon" href="../../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../chalk_solve/index.html'><div class='logo-container'><img src='../../../rust-logo.png' alt='logo'></div></a><p class='location'>Trait ToProgramClauses</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#required-methods">Required Methods</a><div class="sidebar-links"><a href="#tymethod.to_program_clauses">to_program_clauses</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class='location'><a href='../../index.html'>chalk_solve</a>::<wbr><a href='../index.html'>clauses</a>::<wbr><a href='index.html'>program_clauses</a></p><script>window.sidebarCurrent = {name: 'ToProgramClauses', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../../settings.html"><img src="../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#13-15' title='goto source code'>[src]</a></span><span class='in-band'>Trait <a href='../../index.html'>chalk_solve</a>::<wbr><a href='../index.html'>clauses</a>::<wbr><a href='index.html'>program_clauses</a>::<wbr><a class="trait" href=''>ToProgramClauses</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust trait'>pub trait ToProgramClauses&lt;I:&nbsp;<a class="trait" href="../../../chalk_ir/interner/trait.Interner.html" title="trait chalk_ir::interner::Interner">Interner</a>&gt; {
    fn <a href='#tymethod.to_program_clauses' class='fnname'>to_program_clauses</a>(&amp;self, builder: &amp;mut <a class="struct" href="../../../chalk_solve/clauses/builder/struct.ClauseBuilder.html" title="struct chalk_solve::clauses::builder::ClauseBuilder">ClauseBuilder</a>&lt;I&gt;);
}</pre></div><div class='docblock'><p>Trait for lowering a given piece of rust-ir source (e.g., an impl
or struct definition) into its associated &quot;program clauses&quot; --
that is, into the lowered, logical rules that it defines.</p>
</div>
            <h2 id='required-methods' class='small-section-header'>Required methods<a href='#required-methods' class='anchor'></a></h2><div class='methods'><h3 id='tymethod.to_program_clauses' class='method'><code id='to_program_clauses.v'>fn <a href='#tymethod.to_program_clauses' class='fnname'>to_program_clauses</a>(&amp;self, builder: &amp;mut <a class="struct" href="../../../chalk_solve/clauses/builder/struct.ClauseBuilder.html" title="struct chalk_solve::clauses::builder::ClauseBuilder">ClauseBuilder</a>&lt;I&gt;)</code></h3></div><span class='loading-content'>Loading content...</span>
            <h2 id='implementors' class='small-section-header'>Implementors<a href='#implementors' class='anchor'></a></h2><div class='item-list' id='implementors-list'><h3 id='impl-ToProgramClauses%3CI%3E' class='impl'><code class='in-band'>impl&lt;I:&nbsp;<a class="trait" href="../../../chalk_ir/interner/trait.Interner.html" title="trait chalk_ir::interner::Interner">Interner</a>&gt; ToProgramClauses&lt;I&gt; for <a class="struct" href="../../../chalk_solve/rust_ir/struct.AdtDatum.html" title="struct chalk_solve::rust_ir::AdtDatum">AdtDatum</a>&lt;I&gt;</code><a href='#impl-ToProgramClauses%3CI%3E' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#306-424' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses' class="method"><code id='to_program_clauses.v-1'>fn <a href='#method.to_program_clauses' class='fnname'>to_program_clauses</a>(&amp;self, builder: &amp;mut <a class="struct" href="../../../chalk_solve/clauses/builder/struct.ClauseBuilder.html" title="struct chalk_solve::clauses::builder::ClauseBuilder">ClauseBuilder</a>&lt;I&gt;)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#355' title='goto source code'>[src]</a></h4><div class='docblock'><p>Given the following type definition: <code>struct Foo&lt;T: Eq&gt; { }</code>, generate:</p>
<pre><code class="language-notrust">-- Rule WellFormed-Type
forall&lt;T&gt; {
    WF(Foo&lt;T&gt;) :- WF(T: Eq).
}

-- Rule Implied-Bound-From-Type
forall&lt;T&gt; {
    FromEnv(T: Eq) :- FromEnv(Foo&lt;T&gt;).
}

forall&lt;T&gt; {
    IsFullyVisible(Foo&lt;T&gt;) :- IsFullyVisible(T).
}
</code></pre>
<p>If the type <code>Foo</code> is marked <code>#[upstream]</code>, we also generate:</p>
<pre><code class="language-notrust">forall&lt;T&gt; { IsUpstream(Foo&lt;T&gt;). }
</code></pre>
<p>Otherwise, if the type <code>Foo</code> is not marked <code>#[upstream]</code>, we generate:</p>
<pre><code class="language-notrust">forall&lt;T&gt; { IsLocal(Foo&lt;T&gt;). }
</code></pre>
<p>Given an <code>#[upstream]</code> type that is also fundamental:</p>
<pre><code class="language-notrust">#[upstream]
#[fundamental]
struct Box&lt;T&gt; {}
</code></pre>
<p>We generate the following clauses:</p>
<pre><code class="language-notrust">forall&lt;T&gt; { IsLocal(Box&lt;T&gt;) :- IsLocal(T). }

forall&lt;T&gt; { IsUpstream(Box&lt;T&gt;) :- IsUpstream(T). }

// Generated for both upstream and local fundamental types
forall&lt;T&gt; { DownstreamType(Box&lt;T&gt;) :- DownstreamType(T). }
</code></pre>
</div></div><h3 id='impl-ToProgramClauses%3CI%3E-1' class='impl'><code class='in-band'>impl&lt;I:&nbsp;<a class="trait" href="../../../chalk_ir/interner/trait.Interner.html" title="trait chalk_ir::interner::Interner">Interner</a>&gt; ToProgramClauses&lt;I&gt; for <a class="struct" href="../../../chalk_solve/rust_ir/struct.AssociatedTyDatum.html" title="struct chalk_solve::rust_ir::AssociatedTyDatum">AssociatedTyDatum</a>&lt;I&gt;</code><a href='#impl-ToProgramClauses%3CI%3E-1' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#693-879' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses-1' class="method"><code id='to_program_clauses.v-2'>fn <a href='#method.to_program_clauses-1' class='fnname'>to_program_clauses</a>(&amp;self, builder: &amp;mut <a class="struct" href="../../../chalk_solve/clauses/builder/struct.ClauseBuilder.html" title="struct chalk_solve::clauses::builder::ClauseBuilder">ClauseBuilder</a>&lt;I&gt;)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#762-878' title='goto source code'>[src]</a></h4><div class='docblock'><p>For each associated type, we define the &quot;projection
equality&quot; rules. There are always two; one for a successful normalization,
and one for the &quot;fallback&quot; notion of equality.</p>
<p>Given: (here, <code>'a</code> and <code>T</code> represent zero or more parameters)</p>
<pre><code class="language-notrust">trait Foo {
    type Assoc&lt;'a, T&gt;: Bounds where WC;
}
</code></pre>
<p>we generate the 'fallback' rule:</p>
<pre><code class="language-notrust">-- Rule AliasEq-Placeholder
forall&lt;Self, 'a, T&gt; {
    AliasEq(&lt;Self as Foo&gt;::Assoc&lt;'a, T&gt; = (Foo::Assoc&lt;'a, T&gt;)&lt;Self&gt;).
}
</code></pre>
<p>and</p>
<pre><code class="language-notrust">-- Rule AliasEq-Normalize
forall&lt;Self, 'a, T, U&gt; {
    AliasEq(&lt;T as Foo&gt;::Assoc&lt;'a, T&gt; = U) :-
        Normalize(&lt;T as Foo&gt;::Assoc -&gt; U).
}
</code></pre>
<p>We used to generate an &quot;elaboration&quot; rule like this:</p>
<pre><code class="language-notrust">forall&lt;T&gt; {
    T: Foo :- exists&lt;U&gt; { AliasEq(&lt;T as Foo&gt;::Assoc = U) }.
}
</code></pre>
<p>but this caused problems with the recursive solver. In
particular, whenever normalization is possible, we cannot
solve that projection uniquely, since we can now elaborate
<code>AliasEq</code> to fallback <em>or</em> normalize it. So instead we
handle this kind of reasoning through the <code>FromEnv</code> predicate.</p>
<p>We also generate rules specific to WF requirements and implied bounds:</p>
<pre><code class="language-notrust">-- Rule WellFormed-AssocTy
forall&lt;Self, 'a, T&gt; {
    WellFormed((Foo::Assoc)&lt;Self, 'a, T&gt;) :- WellFormed(Self: Foo), WellFormed(WC).
}

-- Rule Implied-WC-From-AssocTy
forall&lt;Self, 'a, T&gt; {
    FromEnv(WC) :- FromEnv((Foo::Assoc)&lt;Self, 'a, T&gt;).
}

-- Rule Implied-Bound-From-AssocTy
forall&lt;Self, 'a, T&gt; {
    FromEnv(&lt;Self as Foo&gt;::Assoc&lt;'a,T&gt;: Bounds) :- FromEnv(Self: Foo), WC.
}

-- Rule Implied-Trait-From-AssocTy
forall&lt;Self,'a, T&gt; {
    FromEnv(Self: Foo) :- FromEnv((Foo::Assoc)&lt;Self, 'a,T&gt;).
}
</code></pre>
</div></div><h3 id='impl-ToProgramClauses%3CI%3E-2' class='impl'><code class='in-band'>impl&lt;I:&nbsp;<a class="trait" href="../../../chalk_ir/interner/trait.Interner.html" title="trait chalk_ir::interner::Interner">Interner</a>&gt; ToProgramClauses&lt;I&gt; for <a class="struct" href="../../../chalk_solve/rust_ir/struct.AssociatedTyValue.html" title="struct chalk_solve::rust_ir::AssociatedTyValue">AssociatedTyValue</a>&lt;I&gt;</code><a href='#impl-ToProgramClauses%3CI%3E-2' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#41-120' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses-2' class="method"><code id='to_program_clauses.v-3'>fn <a href='#method.to_program_clauses-2' class='fnname'>to_program_clauses</a>(&amp;self, builder: &amp;mut <a class="struct" href="../../../chalk_solve/clauses/builder/struct.ClauseBuilder.html" title="struct chalk_solve::clauses::builder::ClauseBuilder">ClauseBuilder</a>&lt;I&gt;)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#67-119' title='goto source code'>[src]</a></h4><div class='docblock'><p>Given the following trait:</p>
<pre><code class="language-notrust">trait Iterable {
    type IntoIter&lt;'a&gt;: 'a;
}
</code></pre>
<p>Then for the following impl:</p>
<pre><code class="language-notrust">impl&lt;T&gt; Iterable for Vec&lt;T&gt; where T: Clone {
    type IntoIter&lt;'a&gt; = Iter&lt;'a, T&gt;;
}
</code></pre>
<p>we generate:</p>
<pre><code class="language-notrust">-- Rule Normalize-From-Impl
forall&lt;'a, T&gt; {
    Normalize(&lt;Vec&lt;T&gt; as Iterable&gt;::IntoIter&lt;'a&gt; -&gt; Iter&lt;'a, T&gt;&gt;) :-
        Implemented(T: Clone),  // (1)
        Implemented(Iter&lt;'a, T&gt;: 'a).   // (2)
}
</code></pre>
</div></div><h3 id='impl-ToProgramClauses%3CI%3E-3' class='impl'><code class='in-band'>impl&lt;I:&nbsp;<a class="trait" href="../../../chalk_ir/interner/trait.Interner.html" title="trait chalk_ir::interner::Interner">Interner</a>&gt; ToProgramClauses&lt;I&gt; for <a class="struct" href="../../../chalk_solve/rust_ir/struct.FnDefDatum.html" title="struct chalk_solve::rust_ir::FnDefDatum">FnDefDatum</a>&lt;I&gt;</code><a href='#impl-ToProgramClauses%3CI%3E-3' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#426-457' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses-3' class="method"><code id='to_program_clauses.v-4'>fn <a href='#method.to_program_clauses-3' class='fnname'>to_program_clauses</a>(&amp;self, builder: &amp;mut <a class="struct" href="../../../chalk_solve/clauses/builder/struct.ClauseBuilder.html" title="struct chalk_solve::clauses::builder::ClauseBuilder">ClauseBuilder</a>&lt;I&gt;)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#444' title='goto source code'>[src]</a></h4><div class='docblock'><p>Given the following function definition: <code>fn bar&lt;T&gt;() where T: Eq</code>, generate:</p>
<pre><code class="language-notrust">-- Rule WellFormed-Type
forall&lt;T&gt; {
    WF(bar&lt;T&gt;) :- WF(T: Eq)
}

-- Rule Implied-Bound-From-Type
forall&lt;T&gt; {
    FromEnv(T: Eq) :- FromEnv(bar&lt;T&gt;).
}

forall&lt;T&gt; {
    IsFullyVisible(bar&lt;T&gt;) :- IsFullyVisible(T).
}
</code></pre>
</div></div><h3 id='impl-ToProgramClauses%3CI%3E-4' class='impl'><code class='in-band'>impl&lt;I:&nbsp;<a class="trait" href="../../../chalk_ir/interner/trait.Interner.html" title="trait chalk_ir::interner::Interner">Interner</a>&gt; ToProgramClauses&lt;I&gt; for <a class="struct" href="../../../chalk_solve/rust_ir/struct.ImplDatum.html" title="struct chalk_solve::rust_ir::ImplDatum">ImplDatum</a>&lt;I&gt;</code><a href='#impl-ToProgramClauses%3CI%3E-4' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#17-39' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses-4' class="method"><code id='to_program_clauses.v-5'>fn <a href='#method.to_program_clauses-4' class='fnname'>to_program_clauses</a>(&amp;self, builder: &amp;mut <a class="struct" href="../../../chalk_solve/clauses/builder/struct.ClauseBuilder.html" title="struct chalk_solve::clauses::builder::ClauseBuilder">ClauseBuilder</a>&lt;I&gt;)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#31-38' title='goto source code'>[src]</a></h4><div class='docblock'><p>Given <code>impl&lt;T: Clone&gt; Clone for Vec&lt;T&gt; { ... }</code>, generate:</p>
<pre><code class="language-notrust">-- Rule Implemented-From-Impl
forall&lt;T&gt; {
    Implemented(Vec&lt;T&gt;: Clone) :- Implemented(T: Clone).
}
</code></pre>
<p>For a negative impl like <code>impl... !Clone for ...</code>, however, we
generate nothing -- this is just a way to <em>opt out</em> from the
default auto trait impls, it doesn't have any positive effect
on its own.</p>
</div></div><h3 id='impl-ToProgramClauses%3CI%3E-5' class='impl'><code class='in-band'>impl&lt;I:&nbsp;<a class="trait" href="../../../chalk_ir/interner/trait.Interner.html" title="trait chalk_ir::interner::Interner">Interner</a>&gt; ToProgramClauses&lt;I&gt; for <a class="struct" href="../../../chalk_solve/rust_ir/struct.OpaqueTyDatum.html" title="struct chalk_solve::rust_ir::OpaqueTyDatum">OpaqueTyDatum</a>&lt;I&gt;</code><a href='#impl-ToProgramClauses%3CI%3E-5' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#122-181' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses-5' class="method"><code id='to_program_clauses.v-6'>fn <a href='#method.to_program_clauses-5' class='fnname'>to_program_clauses</a>(&amp;self, builder: &amp;mut <a class="struct" href="../../../chalk_solve/clauses/builder/struct.ClauseBuilder.html" title="struct chalk_solve::clauses::builder::ClauseBuilder">ClauseBuilder</a>&lt;I&gt;)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#132' title='goto source code'>[src]</a></h4><div class='docblock'><p>Given <code>opaque type T&lt;..&gt;: A + B = HiddenTy;</code>, we generate:</p>
<pre><code class="language-notrust">AliasEq(T&lt;..&gt; = HiddenTy) :- Reveal.
AliasEq(T&lt;..&gt; = !T&lt;..&gt;).
Implemented(!T&lt;..&gt;: A).
Implemented(!T&lt;..&gt;: B).
</code></pre>
<p>where <code>!T&lt;..&gt;</code> is the placeholder for the unnormalized type <code>T&lt;..&gt;</code>.</p>
</div></div><h3 id='impl-ToProgramClauses%3CI%3E-6' class='impl'><code class='in-band'>impl&lt;I:&nbsp;<a class="trait" href="../../../chalk_ir/interner/trait.Interner.html" title="trait chalk_ir::interner::Interner">Interner</a>&gt; ToProgramClauses&lt;I&gt; for <a class="struct" href="../../../chalk_solve/rust_ir/struct.TraitDatum.html" title="struct chalk_solve::rust_ir::TraitDatum">TraitDatum</a>&lt;I&gt;</code><a href='#impl-ToProgramClauses%3CI%3E-6' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#459-691' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses-6' class="method"><code id='to_program_clauses.v-7'>fn <a href='#method.to_program_clauses-6' class='fnname'>to_program_clauses</a>(&amp;self, builder: &amp;mut <a class="struct" href="../../../chalk_solve/clauses/builder/struct.ClauseBuilder.html" title="struct chalk_solve::clauses::builder::ClauseBuilder">ClauseBuilder</a>&lt;I&gt;)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#573-690' title='goto source code'>[src]</a></h4><div class='docblock'><p>Given the following trait declaration: <code>trait Ord&lt;T&gt; where Self: Eq&lt;T&gt; { ... }</code>, generate:</p>
<pre><code class="language-notrust">-- Rule WellFormed-TraitRef
forall&lt;Self, T&gt; {
   WF(Self: Ord&lt;T&gt;) :- Implemented(Self: Ord&lt;T&gt;), WF(Self: Eq&lt;T&gt;).
}
</code></pre>
<p>and the reverse rules:</p>
<pre><code class="language-notrust">-- Rule Implemented-From-Env
forall&lt;Self, T&gt; {
   (Self: Ord&lt;T&gt;) :- FromEnv(Self: Ord&lt;T&gt;).
}

-- Rule Implied-Bound-From-Trait
forall&lt;Self, T&gt; {
    FromEnv(Self: Eq&lt;T&gt;) :- FromEnv(Self: Ord&lt;T&gt;).
}
</code></pre>
<p>As specified in the orphan rules, if a trait is not marked <code>#[upstream]</code>, the current crate
can implement it for any type. To represent that, we generate:</p>
<pre><code class="language-notrust">// `Ord&lt;T&gt;` would not be `#[upstream]` when compiling `std`
forall&lt;Self, T&gt; { LocalImplAllowed(Self: Ord&lt;T&gt;). }
</code></pre>
<p>For traits that are <code>#[upstream]</code> (i.e. not in the current crate), the orphan rules dictate
that impls are allowed as long as at least one type parameter is local and each type
prior to that is fully visible. That means that each type prior to the first local
type cannot contain any of the type parameters of the impl.</p>
<p>This rule is fairly complex, so we expand it and generate a program clause for each
possible case. This is represented as follows:</p>
<pre><code class="language-notrust">// for `#[upstream] trait Foo&lt;T, U, V&gt; where Self: Eq&lt;T&gt; { ... }`
forall&lt;Self, T, U, V&gt; {
    LocalImplAllowed(Self: Foo&lt;T, U, V&gt;) :- IsLocal(Self).
}

forall&lt;Self, T, U, V&gt; {
    LocalImplAllowed(Self: Foo&lt;T, U, V&gt;) :-
        IsFullyVisible(Self),
        IsLocal(T).
}

forall&lt;Self, T, U, V&gt; {
    LocalImplAllowed(Self: Foo&lt;T, U, V&gt;) :-
        IsFullyVisible(Self),
        IsFullyVisible(T),
        IsLocal(U).
}

forall&lt;Self, T, U, V&gt; {
    LocalImplAllowed(Self: Foo&lt;T, U, V&gt;) :-
        IsFullyVisible(Self),
        IsFullyVisible(T),
        IsFullyVisible(U),
        IsLocal(V).
}
</code></pre>
<p>The overlap check uses compatible { ... } mode to ensure that it accounts for impls that
may exist in some other <em>compatible</em> world. For every upstream trait, we add a rule to
account for the fact that upstream crates are able to compatibly add impls of upstream
traits for upstream types.</p>
<pre><code class="language-notrust">// For `#[upstream] trait Foo&lt;T, U, V&gt; where Self: Eq&lt;T&gt; { ... }`
forall&lt;Self, T, U, V&gt; {
    Implemented(Self: Foo&lt;T, U, V&gt;) :-
        Implemented(Self: Eq&lt;T&gt;), // where clauses
        Compatible,               // compatible modality
        IsUpstream(Self),
        IsUpstream(T),
        IsUpstream(U),
        IsUpstream(V),
        CannotProve.              // returns ambiguous
}
</code></pre>
<p>In certain situations, this is too restrictive. Consider the following code:</p>
<pre><code class="language-notrust">/* In crate std */
trait Sized { }
struct str { }

/* In crate bar (depends on std) */
trait Bar { }
impl Bar for str { }
impl&lt;T&gt; Bar for T where T: Sized { }
</code></pre>
<p>Here, because of the rules we've defined, these two impls overlap. The std crate is
upstream to bar, and thus it is allowed to compatibly implement Sized for str. If str
can implement Sized in a compatible future, these two impls definitely overlap since the
second impl covers all types that implement Sized.</p>
<p>The solution we've got right now is to mark Sized as &quot;fundamental&quot; when it is defined.
This signals to the Rust compiler that it can rely on the fact that str does not
implement Sized in all contexts. A consequence of this is that we can no longer add an
implementation of Sized compatibly for str. This is the trade off you make when defining
a fundamental trait.</p>
<p>To implement fundamental traits, we simply just do not add the rule above that allows
upstream types to implement upstream traits. Fundamental traits are not allowed to
compatibly do that.</p>
</div></div></div><span class='loading-content'>Loading content...</span><script type="text/javascript" src="../../../implementors/chalk_solve/clauses/program_clauses/trait.ToProgramClauses.js" async></script></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../../";window.currentCrate = "chalk_solve";</script><script src="../../../aliases.js"></script><script src="../../../main.js"></script><script defer src="../../../search-index.js"></script></body></html>